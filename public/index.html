<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CADDO 911 LIVE</title>
  <link rel="icon" href="images/caddo911logo.png" type="image/png">
  <link rel="icon" href="images/caddo911logo.webp" type="image/webp">
  <link rel="apple-touch-icon" href="images/caddo911logo.png">
  <meta property="og:title" content="Caddo 911 Live Feed">
  <meta property="og:description" content="Live emergency incident map for Caddo Parish, Louisiana.">
  <meta property="og:image" content="images/caddo911logo.png">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="images/caddo911logo.png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header class="header">
    <div class="logo">
      <picture class="logo-icon">
        <source srcset="images/caddo911logo.webp" type="image/webp">
        <img src="images/caddo911logo.png" alt="Caddo 911" class="logo-icon-img">
      </picture>
      <div class="logo-text">
        <h1>CADDO PARISH</h1>
        <p>Emergency Dispatch Live Feed</p>
      </div>
    </div>
    <div class="status-bar">
      <div class="status-item">
        <span class="status-label">Status</span>
        <span class="status-value live"><span class="live-dot"></span>LIVE</span>
      </div>
      <div class="status-item">
        <span class="status-label">Last Update</span>
        <span class="status-value" id="last-update">--:--</span>
      </div>
      <div class="status-item">
        <span class="status-label">Active</span>
        <span class="status-value" id="active-count">0</span>
      </div>
      <div class="status-item">
        <span class="status-label">Map Theme</span>
        <button class="map-theme-toggle" id="map-theme-toggle" aria-pressed="true" title="Toggle map theme">
          <span class="map-theme-icon" aria-hidden="true">‚òÄÔ∏è</span>
        </button>
      </div>
      <button class="info-btn" onclick="toggleInfoPanel()" title="About">i</button>
    </div>
  </header>
  
  <div class="info-modal" id="info-modal" aria-hidden="true">
    <div class="modal-backdrop" role="presentation"></div>
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-label="About Caddo 911 Live">
      <button class="modal-close" type="button" aria-label="Close" id="info-close">√ó</button>
      <div class="info-content">
        <div class="info-hero">
          <img src="https://www.vincentlarkin.com/images/site-emblem.png" alt="Vincent Larkin emblem" class="info-logo">
          <div>
            <h3>Caddo 911 Live Feed</h3>
            <p style="margin-bottom: 6px;">Real-time emergency incident tracker for Caddo Parish, Louisiana.</p>
            <p style="margin-bottom: 0;">Built and maintained by Vincent Larkin.</p>
          </div>
        </div>
        
        <div class="notion-callout" role="note" aria-label="Disclaimer">
          <div class="icon" aria-hidden="true">i</div>
          <p>
            This website is a citizen-run project and is not affiliated with or endorsed by the State of Louisiana, any Louisiana state agency, Caddo Parish, or any Caddo Parish department or technology system. No state or parish funds were used to create or operate this project. <strong>$0.00</strong> of public funding has been spent on this website.
          </p>
        </div>
        
        <div class="info-links">
          <a href="https://github.com/vincentlarkin/Caddo911-Monitor" target="_blank" class="info-link">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
            GitHub
          </a>
          <a href="https://vincentlarkin.com" target="_blank" class="info-link">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
            Website
          </a>
          <a href="https://linkedin.com/in/vincentwlarkin" target="_blank" class="info-link">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
            LinkedIn
          </a>
        </div>
        <p class="info-credit">Created by Vincent Larkin</p>
      </div>
    </div>
  </div>
  
  <main class="main-container">
    <div class="map-container">
      <div id="map"></div>
      <div class="legend-container" id="legend-container">
        <div class="map-overlay" id="map-legend">
          <button class="legend-collapse" id="legend-collapse" type="button" aria-expanded="true" aria-label="Collapse legend" title="Collapse legend">‚óÄ</button>
          
          <!-- Collapsed "handle" view (drawer-closed) -->
          <div class="legend-mini" aria-hidden="true">
            <div class="dot-stack">
              <span class="dot" style="background: var(--red);"></span>
              <span class="dot" style="background: var(--amber);"></span>
              <span class="dot" style="background: var(--blue);"></span>
            </div>
          </div>
          
          <!-- Expanded content -->
          <div class="legend-content">
            <h3>Legend</h3>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--red)"></div>
              <span>High severity</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--amber)"></div>
              <span>Medium severity</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--blue)"></div>
              <span>Low severity</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--green)"></div>
              <span>Public service</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--gray)"></div>
              <span>Custody / prisoner</span>
            </div>
            <div style="margin-top: 10px; font-size: 10px; color: var(--text-dim); line-height: 1.4;">
              Colors = severity. Use the sidebar filters to limit by agency.
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <aside class="sidebar">
      <div class="tabs">
        <button class="tab active" data-tab="live">Live</button>
        <button class="tab" data-tab="history">History</button>
      </div>

      <!-- Shared filters (apply to Live + History lists) -->
      <div class="filter-bar">
        <div class="filter-rows">
          <!-- Agency filters -->
          <div class="filter-group" data-filter-type="agency">
            <button class="filter-btn active" data-filter="all" title="All agencies">All</button>
            <button class="filter-btn" data-filter="cadfd" title="Caddo Fire/EMS">
              <img src="images/cfd-fire.png" alt="CAD-FD/EMS" class="filter-logo">
            </button>
            <button class="filter-btn" data-filter="shvfd" title="Shreveport Fire">
              <img src="images/sfd-fire.png" alt="SHVFD" class="filter-logo">
            </button>
            <button class="filter-btn" data-filter="police" title="Shreveport Police">
              <img src="images/spd-police.png" alt="Police" class="filter-logo">
            </button>
            <button class="filter-btn" data-filter="sheriff" title="Caddo Sheriff">
              <img src="images/cso-sheriff.png" alt="Sheriff" class="filter-logo">
            </button>
          </div>
          <!-- Urgency/Severity filters -->
          <div class="filter-group" data-filter-type="urgency">
            <button class="filter-btn urgency-btn active" data-urgency="all" title="All severity levels">All</button>
            <button class="filter-btn urgency-btn urgency-high" data-urgency="high" title="High severity">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-medical" data-urgency="medical" title="Medical/EMS">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-medium" data-urgency="medium" title="Medium severity">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-low" data-urgency="low" title="Low severity">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-service" data-urgency="service" title="Public service">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-custody" data-urgency="custody" title="Custody/Prisoner">
              <span class="urgency-dot"></span>
            </button>
          </div>
        </div>
        <div class="filter-meta">
          <div class="history-count hidden" id="history-count">
            <span class="history-count-label" id="history-count-label">Incidents</span>
            <strong id="history-count-value">0</strong>
          </div>
          <div class="sort-control" id="sort-control">
            <button type="button" class="sort-btn" id="sort-toggle" aria-expanded="false" aria-controls="sort-menu" title="Sort incidents">
              <span>Sort</span>
              <svg class="sort-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <path d="M3 5h18v2H3V5zm4 6h10v2H7v-2zm4 6h2v2h-2v-2z"/>
              </svg>
            </button>
            <div class="sort-menu" id="sort-menu" aria-hidden="true">
              <button type="button" class="sort-option active" data-sort="recent">Most recent</button>
              <button type="button" class="sort-option" data-sort="urgency">Urgency</button>
            </div>
          </div>
        </div>
      </div>
      
      <div id="live-panel">
        <div class="incident-list" id="incident-list"></div>
      </div>
      
      <div id="history-panel" class="hidden">
        <div class="history-controls">
          <button type="button" id="history-date-btn" class="date-input" aria-expanded="false" aria-controls="date-picker">
            <div class="date-input-left">
              <div class="date-input-label">History date</div>
              <div class="date-input-value" id="history-date-value">----</div>
            </div>
            <svg class="date-input-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M7 11h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM7 15h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z"/>
              <path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"/>
            </svg>
          </button>
          <div class="date-picker" id="date-picker" aria-hidden="true"></div>
          <div class="history-pagination hidden" id="history-pagination" aria-label="History pages">
            <button type="button" class="page-btn" id="history-prev" aria-label="Previous page">‚Äπ</button>
            <div class="page-status" id="history-page-status">Page 1 of 1</div>
            <button type="button" class="page-btn" id="history-next" aria-label="Next page">‚Ä∫</button>
          </div>
        </div>
        <div class="incident-list" id="history-list"></div>
      </div>
    </aside>
  </main>
  
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Initialize map centered on Shreveport/Caddo Parish
    const map = L.map('map', {
      zoomControl: false,
      minZoom: 7,
      maxZoom: 19,
      worldCopyJump: true
    }).setView([32.5252, -93.7502], 11);
    
    // Keep view constrained to a few-state window around Louisiana/Texas/Arkansas
    const southWest = L.latLng(29.0, -98.0);
    const northEast = L.latLng(34.5, -90.0);
    map.setMaxBounds(L.latLngBounds(southWest, northEast));
    
    // Dark basemap (keeps the UI in dark mode) with a separate label overlay for readability.
    // Base (no labels) in its own pane so we can color-grade it without affecting labels.
    map.createPane('base');
    map.getPane('base').classList.add('leaflet-base-pane');
    map.getPane('base').style.zIndex = 200;

    map.createPane('labels');
    map.getPane('labels').classList.add('leaflet-labels-pane');
    map.getPane('labels').style.zIndex = 650;
    map.getPane('labels').style.pointerEvents = 'none';

    map.createPane('parish');
    map.getPane('parish').classList.add('leaflet-parish-pane');
    map.getPane('parish').style.zIndex = 500;
    map.getPane('parish').style.pointerEvents = 'none';

    // Tile layers for light + dark themes
    const lightBase = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
      pane: 'base',
      attribution: '&copy; OpenStreetMap &copy; CARTO',
      subdomains: 'abcd',
      maxZoom: 19,
      crossOrigin: true
    });
    const lightLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
      pane: 'labels',
      subdomains: 'abcd',
      maxZoom: 19,
      opacity: 0.65,
      crossOrigin: true
    });
    const osmFallbackTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      pane: 'base',
      attribution: '&copy; OpenStreetMap contributors',
      maxZoom: 19,
      subdomains: 'abc',
      crossOrigin: true
    });
    const tileLayers = {
      dark: {
        base: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
          pane: 'base',
          attribution: '&copy; OpenStreetMap &copy; CARTO',
          subdomains: 'abcd',
          maxZoom: 19
        }),
        labels: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', {
          pane: 'labels',
          subdomains: 'abcd',
          maxZoom: 19,
          opacity: 1
        })
      },
      light: {
        base: lightBase,
        labels: lightLabels
      }
    };
    
    let mapTheme = 'light';
    let parishOutlineLayer = null;
    
    function setMapTheme(theme) {
      mapTheme = theme === 'dark' ? 'dark' : 'light';
      // Remove any existing layers
      Object.values(tileLayers.dark).forEach(layer => { if (map.hasLayer(layer)) map.removeLayer(layer); });
      Object.values(tileLayers.light).forEach(layer => { if (map.hasLayer(layer)) map.removeLayer(layer); });
      
      const layersToAdd = tileLayers[mapTheme];
      Object.values(layersToAdd).forEach(layer => layer.addTo(map));
      
      // If light tiles fail, fall back to standard OSM automatically
      if (mapTheme === 'light' && layersToAdd.base === lightBase) {
        const onError = () => {
          if (map.hasLayer(lightBase)) {
            map.removeLayer(lightBase);
            osmFallbackTiles.addTo(map);
            tileLayers.light.base = osmFallbackTiles;
            // drop labels to avoid mismatch
            if (map.hasLayer(lightLabels)) map.removeLayer(lightLabels);
            delete tileLayers.light.labels;
          }
        };
        lightBase.once('tileerror', onError);
      }
      
      document.body.classList.toggle('map-light', mapTheme === 'light');
      document.body.classList.toggle('map-dark', mapTheme === 'dark');
      
      const toggle = document.getElementById('map-theme-toggle');
      if (toggle) {
        const iconEl = toggle.querySelector('.map-theme-icon');
        if (iconEl) iconEl.textContent = mapTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
        toggle.setAttribute('aria-pressed', String(mapTheme === 'light'));
      }

      if (parishOutlineLayer) {
        parishOutlineLayer.setStyle(getParishOutlineStyle());
      }
    }
    
    // Default to dark mode
    setMapTheme('dark');

    function getParishOutlineStyle() {
      return {
        pane: 'parish',
        color: mapTheme === 'dark' ? 'rgba(232, 232, 240, 0.45)' : 'rgba(10, 10, 15, 0.6)',
        weight: 2,
        opacity: 0.95,
        fill: false
      };
    }

    async function loadParishOutline() {
      if (parishOutlineLayer) return;
      try {
        const response = await fetch('https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json');
        if (!response.ok) throw new Error(`Failed to load parish outline: ${response.status}`);
        const geojson = await response.json();
        const feature = (geojson?.features || []).find(f => String(f?.id) === '22017');
        if (!feature) return;
        parishOutlineLayer = L.geoJSON(feature, { style: getParishOutlineStyle() });
        parishOutlineLayer.addTo(map);
      } catch (error) {
        console.error(error);
      }
    }
    
    // Legend drawer (auto-collapse on narrow screens)
    const legendContainer = document.getElementById('legend-container');
    const legendPanel = document.getElementById('map-legend');
    const legendCollapse = document.getElementById('legend-collapse');
    let legendExpandedHeight = null;
    
    function measureLegendExpandedHeight() {
      if (!legendPanel) return;
      // Ensure height is auto for measurement
      legendPanel.style.height = '';
      legendExpandedHeight = legendPanel.offsetHeight;
    }
    
    function setLegendCollapsed(collapsed) {
      if (!legendContainer || !legendPanel) return;
      legendContainer.classList.toggle('collapsed', collapsed);
      
      // Keep the same height (drawer closes horizontally only)
      if (collapsed && legendExpandedHeight) {
        legendPanel.style.height = `${legendExpandedHeight}px`;
      } else {
        legendPanel.style.height = '';
        // When expanding, refresh measured height for the current layout
        requestAnimationFrame(measureLegendExpandedHeight);
      }
      
      if (legendCollapse) {
        legendCollapse.setAttribute('aria-expanded', String(!collapsed));
        legendCollapse.textContent = collapsed ? '‚ñ∂' : '‚óÄ';
        legendCollapse.title = collapsed ? 'Expand legend' : 'Collapse legend';
        legendCollapse.setAttribute('aria-label', collapsed ? 'Expand legend' : 'Collapse legend');
      }
    }
    
    // Initial measurement (expanded state), then optionally collapse for smaller screens
    measureLegendExpandedHeight();
    if (window.innerWidth < 960) setLegendCollapsed(true);
    
    legendCollapse?.addEventListener('click', () => {
      const isCollapsed = legendContainer?.classList.contains('collapsed');
      setLegendCollapsed(!isCollapsed);
    });
    
    // Keep measurements accurate if the layout changes
    window.addEventListener('resize', () => {
      if (!legendContainer?.classList.contains('collapsed')) {
        measureLegendExpandedHeight();
      }
    });
    
    // Add zoom control to bottom right
    L.control.zoom({ position: 'bottomright' }).addTo(map);
    
    const mapThemeToggle = document.getElementById('map-theme-toggle');
    if (mapThemeToggle) {
      mapThemeToggle.addEventListener('click', () => {
        setMapTheme(mapTheme === 'light' ? 'dark' : 'light');
      });
    }
    
    // Store markers
    const markers = new Map();
    let currentIncidents = [];
    let currentHistoryIncidents = [];
    let currentFilter = 'all';  // Agency filter
    let currentUrgencyFilter = 'all';  // Urgency/severity filter
    let currentSort = 'recent'; // 'recent' | 'urgency'
    let mapMode = 'live'; // 'live' | 'history'
    let historyPage = 1;
    const historyPageSize = 35;
    let historyTotal = 0;
    
    // Agency color mapping
    function getAgencyColor(agency) {
      if (agency.startsWith('CFD') || agency.startsWith('SFD')) return '#ff6b35'; // Fire
      if (agency === 'EMS' || agency.includes('EMS')) return '#ff3b6b'; // Medical
      if (agency === 'SPD') return '#3b8bff'; // Police
      if (agency === 'CSO') return '#9b59b6'; // Sheriff
      return '#ffb830'; // Other
    }
    
    function getAgencyClass(agency) {
      if (agency.startsWith('CFD') || agency.startsWith('SFD')) return 'fire';
      if (agency === 'EMS' || agency.includes('EMS')) return 'medical';
      if (agency === 'SPD') return 'police';
      if (agency === 'CSO') return 'sheriff';
      return 'other';
    }
    
    // Severity classification (meaningful colors)
    // - high: life safety / violence / fire / serious traffic
    // - medium: theft / hazards / accidents
    // - low: follow-up / reports / citizen assist
    function _normalizeDesc(description) {
      return String(description || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function _includesAny(text, terms) {
      for (const t of terms) {
        if (text.includes(t)) return true;
      }
      return false;
    }

    function getSeverity(incident) {
      const d = _normalizeDesc(incident?.description);
      const agency = String(incident?.agency || '').toUpperCase();

      const CUSTODY = [
        'prisoner',
      ];

      const MEDICAL_EMERGENCY = [
        'medical emergency',
        'caddo ems event',
      ];

      const SERVICE = [
        'special event stand by',
        'public service',
      ];

      // Explicit low-priority / administrative / follow-up type calls
      const LOW = [
        'deliver message', 'prisoner medical security', 'periodic check', 'taken by other agency',
        'follow up', 'followup', 'follow', 'investigation', 'report', 'information',
        'citizen assist', 'citizen assistance', 'assist citizen', 'civil',
        'welfare check', 'wellness check', 'property check', 'extra patrol', 'directed patrol',
        'noise', 'complaint', 'parking', 'traffic control', 'traffic stop',
        'lost property', 'found property',
      ];

      // High-severity life safety / violence / weapons / fire / critical medical
      const HIGH = [
        // Violence / weapons
        'shots fired', 'shooting', 'shot fired', 'gun', 'armed', 'weapon',
        'stabbing', 'stab', 'knife',
        'assault', 'battery', 'domestic', 'fight',
        'robbery', 'home invasion', 'kidnap', 'hostage',
        'homicide', 'murder', 'rape', 'sexual',
        // Crime (treat as high priority)
        'theft', 'burglary', 'vehicle burglary', 'break in', 'breaking entering',
        // Fire
        'structure fire', 'house fire', 'apartment fire', 'building fire',
        'fire', 'smoke', 'explosion',
        // Medical
        'medical', 'ems', 'unconscious', 'not breathing', 'difficulty breathing', 'choking',
        'overdose', 'cardiac', 'heart', 'stroke', 'seizure',
        // Traffic (serious)
        'hit and run', 'hit run', 'injury accident', 'accident with injuries', 'fatal', 'entrap', 'rollover',
      ];

      // Medium-severity incidents (default bucket if not high/low)
      const MEDIUM = [
        // Theft / property crime
        'stolen', 'shoplift', 'vandal',
        // Traffic / hazard
        'accident', 'crash', 'wreck', 'collision', 'mvc', 'mva',
        'road hazard', 'debris', 'disabled vehicle',
        // Animals
        'loose livestock', 'livestock', 'loose animal', 'animal in roadway', 'cow', 'horse',
        // General police calls
        'disturbance', 'suspicious', 'trespass', 'harassment', 'fraud', 'alarm',
        'juvenile complaint',
      ];

      // Special-cases: "minor accident" should not be treated like a high-priority crime call.
      if (d.includes('minor accident') || d.includes('minor crash') || d.includes('fender bender')) {
        return 'low';
      }

      if (_includesAny(d, CUSTODY)) return 'custody';
      if (agency === 'EMS' || agency.includes('EMS')) return 'medical';
      if (_includesAny(d, MEDICAL_EMERGENCY)) return 'medical';
      if (_includesAny(d, SERVICE)) return 'service';
      if (_includesAny(d, HIGH)) return 'high';
      if (_includesAny(d, LOW)) return 'low';
      if (_includesAny(d, MEDIUM)) return 'medium';

      // If we can't classify: default to medium (safer than understating severity).
      // EMS agency tends to be life-safety oriented.
      if (agency === 'EMS' || agency.includes('EMS')) {
        return 'high';
      }
      return 'medium';
    }

    function getSeverityClass(sev) {
      if (sev === 'medical') return 'sev-medical';
      if (sev === 'custody') return 'sev-custody';
      if (sev === 'service') return 'sev-service';
      return sev === 'high' ? 'sev-high' : sev === 'low' ? 'sev-low' : 'sev-medium';
    }

    function getSeverityColor(sev) {
      if (sev === 'high' || sev === 'medical') return '#ff3b3b';
      if (sev === 'custody') return '#9aa0aa';
      if (sev === 'service') return '#00ff88';
      if (sev === 'low') return '#3b8bff';
      return '#ffb830';
    }

    const MARKER_PATTERN_IDS = {
      medical: 'marker-pattern-medical',
      custody: 'marker-pattern-custody',
    };

    function ensureMarkerPatterns() {
      const overlay = map.getPanes().overlayPane;
      const svg = overlay ? overlay.querySelector('svg') : null;
      if (!svg) return;

      let defs = svg.querySelector('defs');
      if (!defs) {
        defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        svg.insertBefore(defs, svg.firstChild);
      }

      const ns = 'http://www.w3.org/2000/svg';
      const ensurePattern = (id, { primary, secondary }) => {
        if (defs.querySelector(`#${id}`)) return;
        const pattern = document.createElementNS(ns, 'pattern');
        pattern.setAttribute('id', id);
        pattern.setAttribute('patternUnits', 'userSpaceOnUse');
        pattern.setAttribute('width', '12');
        pattern.setAttribute('height', '12');
        pattern.setAttribute('patternTransform', 'rotate(135)');

        const bg = document.createElementNS(ns, 'rect');
        bg.setAttribute('width', '12');
        bg.setAttribute('height', '12');
        bg.setAttribute('fill', secondary);
        pattern.appendChild(bg);

        const stripe = document.createElementNS(ns, 'rect');
        stripe.setAttribute('width', '6');
        stripe.setAttribute('height', '12');
        stripe.setAttribute('fill', primary);
        pattern.appendChild(stripe);

        defs.appendChild(pattern);
      };

      ensurePattern(MARKER_PATTERN_IDS.medical, {
        primary: 'rgba(255, 59, 59, 0.45)',
        secondary: 'rgba(255, 255, 255, 0.18)',
      });
      ensurePattern(MARKER_PATTERN_IDS.custody, {
        primary: 'rgba(154, 160, 170, 0.55)',
        secondary: 'rgba(255, 255, 255, 0.16)',
      });
    }

    function getMarkerFill(sev) {
      if (sev === 'medical') return `url(#${MARKER_PATTERN_IDS.medical})`;
      if (sev === 'custody') return `url(#${MARKER_PATTERN_IDS.custody})`;
      return getSeverityColor(sev);
    }
    
    // Filter logic - matches agency codes to filter categories
    function matchesAgencyFilter(incident, filter) {
      if (filter === 'all') return true;
      
      const agency = incident.agency.toUpperCase();
      
      switch (filter) {
        case 'cadfd':
          return agency.startsWith('CFD');
        case 'shvfd':
          return agency.startsWith('SFD');
        case 'police':
          return agency === 'SPD' || agency.includes('POLICE');
        case 'sheriff':
          return agency === 'CSO' || agency.includes('SHERIFF');
        default:
          return true;
      }
    }

    // Urgency filter logic - matches severity levels
    function matchesUrgencyFilter(incident, urgencyFilter) {
      if (urgencyFilter === 'all') return true;
      const sev = getSeverity(incident);
      return sev === urgencyFilter;
    }

    // Combined filter - checks both agency AND urgency
    function matchesFilters(incident, agencyFilter, urgencyFilter) {
      return matchesAgencyFilter(incident, agencyFilter) && matchesUrgencyFilter(incident, urgencyFilter);
    }
    
    function filterLabel(filter) {
      switch (filter) {
        case 'cadfd': return 'CAD-FD/EMS';
        case 'shvfd': return 'SHVFD';
        case 'police': return 'police';
        case 'sheriff': return 'sheriff';
        default: return filter;
      }
    }

    function urgencyLabel(urgency) {
      switch (urgency) {
        case 'high': return 'high severity';
        case 'medical': return 'medical/EMS';
        case 'medium': return 'medium severity';
        case 'low': return 'low severity';
        case 'service': return 'public service';
        case 'custody': return 'custody';
        default: return urgency;
      }
    }

    function getFilteredIncidents(incidents, agencyFilter, urgencyFilter) {
      const af = agencyFilter ?? currentFilter;
      const uf = urgencyFilter ?? currentUrgencyFilter;
      return incidents.filter(inc => matchesFilters(inc, af, uf));
    }

    function _incidentTimeValue(incident) {
      const raw = incident?.time;
      if (raw != null && String(raw).trim() !== '') {
        const normalized = Number(String(raw).padStart(4, '0'));
        if (!Number.isNaN(normalized)) return normalized;
      }
      if (incident?.first_seen) {
        const parsed = Date.parse(incident.first_seen);
        return Number.isNaN(parsed) ? 0 : parsed;
      }
      return 0;
    }

    function _urgencyRank(incident) {
      const sev = getSeverity(incident);
      return sev === 'high' ? 5
        : sev === 'medical' ? 4
        : sev === 'medium' ? 3
        : sev === 'low' ? 2
        : sev === 'service' ? 1
        : 0;
    }

    function sortIncidents(incidents) {
      const list = Array.isArray(incidents) ? [...incidents] : [];
      if (currentSort === 'urgency') {
        return list.sort((a, b) => _urgencyRank(b) - _urgencyRank(a));
      }
      return list.sort((a, b) => _incidentTimeValue(b) - _incidentTimeValue(a));
    }

    // Update filter button visibility and counts for both agency and urgency filters.
    // This dims filters with 0 incidents so users understand they're empty.
    function updateFilterButtonVisibility(baseIncidents) {
      // Agency counts (considering current urgency filter)
      const agencyCounts = {
        cadfd: 0,
        shvfd: 0,
        police: 0,
        sheriff: 0,
      };

      // Urgency counts (considering current agency filter)
      const urgencyCounts = {
        high: 0,
        medical: 0,
        medium: 0,
        low: 0,
        service: 0,
        custody: 0,
      };

      for (const inc of baseIncidents || []) {
        const sev = getSeverity(inc);
        
        // Count for agency filters (apply current urgency filter)
        if (matchesUrgencyFilter(inc, currentUrgencyFilter)) {
          if (matchesAgencyFilter(inc, 'cadfd')) agencyCounts.cadfd += 1;
          if (matchesAgencyFilter(inc, 'shvfd')) agencyCounts.shvfd += 1;
          if (matchesAgencyFilter(inc, 'police')) agencyCounts.police += 1;
          if (matchesAgencyFilter(inc, 'sheriff')) agencyCounts.sheriff += 1;
        }

        // Count for urgency filters (apply current agency filter)
        if (matchesAgencyFilter(inc, currentFilter)) {
          if (urgencyCounts.hasOwnProperty(sev)) {
            urgencyCounts[sev] += 1;
          }
        }
      }

      // Always show filter "tabs" even when they have 0 incidents.
      // Visually dim them so users understand they‚Äôre empty, but still allow clicking
      // (the list will show a "No incidents" message).
      document.querySelectorAll('.filter-group[data-filter-type="agency"] .filter-btn').forEach(btn => {
        const f = btn.dataset.filter;
        if (f === 'all') {
          btn.dataset.count = '';
          btn.classList.remove('empty');
          return;
        }
        const count = agencyCounts[f] || 0;
        btn.dataset.count = String(count);
        btn.classList.toggle('empty', count === 0);
      });

      // Update urgency filter buttons
      document.querySelectorAll('.filter-group[data-filter-type="urgency"] .filter-btn').forEach(btn => {
        const u = btn.dataset.urgency;
        if (u === 'all') {
          btn.dataset.count = '';
          btn.classList.remove('empty');
          return;
        }
        const count = urgencyCounts[u] || 0;
        btn.dataset.count = String(count);
        btn.classList.toggle('empty', count === 0);
      });

      // If the active agency filter has no incidents (after urgency filter), fall back to "all".
      if (currentFilter !== 'all' && (agencyCounts[currentFilter] || 0) === 0) {
        currentFilter = 'all';
      }

      // If the active urgency filter has no incidents (after agency filter), fall back to "all".
      if (currentUrgencyFilter !== 'all' && (urgencyCounts[currentUrgencyFilter] || 0) === 0) {
        currentUrgencyFilter = 'all';
      }

      // Keep active state consistent (especially after fallback)
      document.querySelectorAll('.filter-group[data-filter-type="agency"] .filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === currentFilter);
      });
      document.querySelectorAll('.filter-group[data-filter-type="urgency"] .filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.urgency === currentUrgencyFilter);
      });
    }
    
    function _stringHash(str) {
      // Stable 32-bit hash for deterministic marker shapes per incident
      let h = 2166136261;
      const s = String(str || '');
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    function _incidentSeed(incident) {
      return _stringHash(incident?.hash || incident?.id || '');
    }

    function _triangleLatLngs(lat, lng, sizeMeters, seed) {
      // Small equilateral-ish triangle around a center point, rotated deterministically.
      const base = [
        [0, 1],
        [-0.866, -0.5],
        [0.866, -0.5],
      ];
      const angle = ((seed % 360) * Math.PI) / 180;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      const latRad = (lat * Math.PI) / 180;
      const mPerDegLat = 111320;
      const mPerDegLng = 111320 * Math.cos(latRad);

      return base.map(([x, y]) => {
        const rx = x * cos - y * sin;
        const ry = x * sin + y * cos;
        const dLat = (ry * sizeMeters) / mPerDegLat;
        const dLng = (rx * sizeMeters) / (mPerDegLng || 1);
        return [lat + dLat, lng + dLng];
      });
    }

    function _geocodeTriangleSizeMeters(incident, mode) {
      const src = String(incident?.geocode_source || '').toLowerCase();
      const q = String(incident?.geocode_quality || '').toLowerCase();

      // Defaults: slightly generalized even for "good" geocodes (avoids false precision).
      let size = mode === 'history' ? 70 : 85;

      if (src === 'fallback' || q === 'fallback' || q === 'city-only') {
        size = mode === 'history' ? 220 : 260;
      } else if (q === 'cross-only') {
        size = mode === 'history' ? 160 : 190;
      } else if (q === 'street-only') {
        size = mode === 'history' ? 140 : 170;
      } else if (q === 'street+cross') {
        size = mode === 'history' ? 90 : 110;
      } else if (q === 'intersection-2') {
        size = mode === 'history' ? 65 : 80;
      }

      return size;
    }

    function googleMapsUrl(lat, lng) {
      const q = `${Number(lat).toFixed(6)},${Number(lng).toFixed(6)}`;
      return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(q)}`;
    }

    // Create custom marker (triangle area instead of pinpoint dot)
    function createMarker(incident, { mode = 'live' } = {}) {
      const sev = getSeverity(incident);
      const color = getSeverityColor(sev);
      const fillColor = getMarkerFill(sev);
      
      const locationParts = [];
      if (incident.street) locationParts.push(incident.street);
      if (incident.cross_streets) locationParts.push(incident.cross_streets);
      const locationStr = locationParts.join(' @ ') || 'Unknown';

      const seed = _incidentSeed(incident);
      const sizeMeters = _geocodeTriangleSizeMeters(incident, mode);
      const points = _triangleLatLngs(incident.latitude, incident.longitude, sizeMeters, seed);
      const gmaps = googleMapsUrl(incident.latitude, incident.longitude);
      
      const hasPattern = sev === 'medical' || sev === 'custody';
      const marker = L.polygon(points, {
        color,
        weight: mode === 'history' ? 1 : 1.2,
        opacity: 0.9,
        fillColor,
        fillOpacity: hasPattern ? (mode === 'history' ? 0.5 : 0.65) : (mode === 'history' ? 0.18 : 0.28),
      })
        // Right-click ‚Üí open in Google Maps (useful on desktop)
        .on('contextmenu', () => {
          window.open(gmaps, '_blank', 'noopener,noreferrer');
        })
        .bindPopup(`
          <div class="popup-content">
            <div class="popup-title">${incident.description}</div>
            <div class="popup-detail">üìç ${locationStr}</div>
            <div class="popup-detail">üïê ${formatTime(incident.time)}</div>
            <div class="popup-detail">üö® ${incident.agency} ‚Ä¢ ${incident.units} unit(s)</div>
            <div class="popup-detail">‚ö†Ô∏è Severity: ${sev.toUpperCase()}</div>
            <a class="popup-link" href="${gmaps}" target="_blank" rel="noopener noreferrer">Open in Google Maps</a>
          </div>
        `);
      
      if (hasPattern) {
        marker.on('add', ensureMarkerPatterns);
      }
      return marker;
    }

    // Replace map markers with the given incident set (used for Live and History modes)
    function setMapMarkers(incidents, { fit = false, mode = mapMode } = {}) {
      const nextIds = new Set((incidents || []).map(i => i.id));

      // Remove markers not in the next set
      markers.forEach((marker, id) => {
        if (!nextIds.has(id)) {
          if (map.hasLayer(marker)) map.removeLayer(marker);
          markers.delete(id);
        }
      });

      // Add missing markers
      (incidents || []).forEach(incident => {
        if (!incident || incident.latitude == null || incident.longitude == null) return;
        if (!markers.has(incident.id)) {
          const marker = createMarker(incident, { mode });
          marker.addTo(map);
          markers.set(incident.id, marker);
        } else {
          const marker = markers.get(incident.id);
          if (marker && !map.hasLayer(marker)) marker.addTo(map);
        }
      });

      if (fit && incidents && incidents.length > 0) {
        try {
          const bounds = L.latLngBounds(incidents.map(i => [i.latitude, i.longitude]));
          map.fitBounds(bounds, { padding: [50, 50], maxZoom: 14 });
        } catch (e) {
          // ignore fit errors
        }
      }
    }
    
    // Format time
    function formatTime(time) {
      if (!time) return '--:--';
      const str = time.toString().padStart(4, '0');
      return `${str.slice(0, 2)}:${str.slice(2)}`;
    }
    
    // Create incident card
    function createIncidentCard(incident, isNew = false) {
      const sev = getSeverity(incident);
      const sevClass = getSeverityClass(sev);
      
      return `
        <div class="incident-card ${sevClass} ${isNew ? 'new' : ''}" 
             data-id="${incident.id}"
             onclick="focusIncident(${incident.latitude}, ${incident.longitude})">
          <div class="incident-header">
            <span class="incident-type">${incident.description}</span>
            <span class="incident-time">${formatTime(incident.time)}</span>
          </div>
          <div class="incident-location">
            üìç ${[incident.street, incident.cross_streets].filter(Boolean).join(' @ ') || 'Unknown'}
          </div>
          <div class="incident-meta">
            <span class="incident-agency ${sevClass}" title="Severity: ${sev.toUpperCase()}">${incident.agency}</span>
            <span class="incident-units">${sev.toUpperCase()} ‚Ä¢ ${incident.units} unit(s) ‚Ä¢ ${incident.municipality}</span>
          </div>
        </div>
      `;
    }
    
    // Focus on incident on map
    window.focusIncident = function(lat, lng) {
      map.flyTo([lat, lng], 15, { duration: 0.5 });
    };
    
    // Info modal
    const infoModal = document.getElementById('info-modal');
    const infoClose = document.getElementById('info-close');
    
    window.toggleInfoPanel = function(forceOpen) {
      if (!infoModal) return;
      const next = typeof forceOpen === 'boolean' ? forceOpen : !infoModal.classList.contains('open');
      infoModal.classList.toggle('open', next);
      infoModal.setAttribute('aria-hidden', String(!next));
      document.body.classList.toggle('modal-open', next);
    };
    
    infoClose?.addEventListener('click', () => toggleInfoPanel(false));
    infoModal?.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-backdrop')) toggleInfoPanel(false);
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && infoModal?.classList.contains('open')) toggleInfoPanel(false);
    });
    
    // Update incidents
    async function updateIncidents() {
      try {
        const response = await fetch('api/incidents/active');
        const allIncidents = await response.json();
        
        // Store all incidents
        currentIncidents = allIncidents;

        // Only update shared filter visibility from the active feed when the Live tab is visible.
        // Otherwise History's filter visibility would get overridden every poll.
        const livePanel = document.getElementById('live-panel');
        const liveVisible = livePanel && !livePanel.classList.contains('hidden');
        if (liveVisible) updateFilterButtonVisibility(allIncidents);
        
        // Apply current filters (agency + urgency)
        const incidents = getFilteredIncidents(allIncidents);
        
        // Update counts
        document.getElementById('active-count').textContent = allIncidents.length;

        // If we're not on the Live tab, don't touch the map/list (History owns the map).
        if (!liveVisible) return;
        
        // Update map + list (filtered)
        setMapMarkers(incidents, { mode: 'live' });
        renderIncidentList(incidents);
        
      } catch (error) {
        console.error('Failed to fetch incidents:', error);
      }
    }
    
    // Render the incident list
    function renderIncidentList(incidents) {
      const listEl = document.getElementById('incident-list');
      const sorted = sortIncidents(incidents);
      if (sorted.length === 0) {
        const hasAgencyFilter = currentFilter !== 'all';
        const hasUrgencyFilter = currentUrgencyFilter !== 'all';
        const hasAnyFilter = hasAgencyFilter || hasUrgencyFilter;
        
        let label = 'active';
        if (hasAgencyFilter && hasUrgencyFilter) {
          label = `${urgencyLabel(currentUrgencyFilter)} ${filterLabel(currentFilter)}`;
        } else if (hasAgencyFilter) {
          label = filterLabel(currentFilter);
        } else if (hasUrgencyFilter) {
          label = urgencyLabel(currentUrgencyFilter);
        }
        
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="icon">üì°</div>
            <p>No ${label} incidents</p>
            <p style="font-size: 11px; margin-top: 10px;">${hasAnyFilter ? 'Try a different filter combination' : 'Waiting for data...'}</p>
          </div>
        `;
      } else {
        listEl.innerHTML = sorted.map(inc => createIncidentCard(inc, false)).join('');
      }
    }
    
    // Apply agency filter and update display
    function applyAgencyFilter(filter) {
      const btn = document.querySelector(`.filter-group[data-filter-type="agency"] .filter-btn[data-filter="${filter}"]`);
      const isEmpty = filter !== 'all' && btn?.classList.contains('empty');
      if (isEmpty) {
        return;
      }
      currentFilter = filter;
      
      // Update agency filter button states
      document.querySelectorAll('.filter-group[data-filter-type="agency"] .filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
      });

      refreshFilteredView();
    }

    // Apply urgency filter and update display
    function applyUrgencyFilter(urgency) {
      const btn = document.querySelector(`.filter-group[data-filter-type="urgency"] .filter-btn[data-urgency="${urgency}"]`);
      const isEmpty = urgency !== 'all' && btn?.classList.contains('empty');
      if (isEmpty) {
        return;
      }
      currentUrgencyFilter = urgency;
      
      // Update urgency filter button states
      document.querySelectorAll('.filter-group[data-filter-type="urgency"] .filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.urgency === urgency);
      });

      refreshFilteredView();
    }

    // Refresh the view with current filters applied
    function refreshFilteredView() {
      const livePanel = document.getElementById('live-panel');
      const historyPanel = document.getElementById('history-panel');
      const liveVisible = livePanel && !livePanel.classList.contains('hidden');
      const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');

      // Update filter button visibility/counts based on current filters
      if (liveVisible) {
        updateFilterButtonVisibility(currentIncidents);
      } else if (historyVisible) {
        updateFilterButtonVisibility(currentHistoryIncidents);
      }

      if (historyVisible) {
        const historyFiltered = getFilteredIncidents(currentHistoryIncidents);
        const offset = (historyPage - 1) * historyPageSize;
        let pageData;
        if (currentSort === 'urgency') {
          const sortedAll = sortIncidents(historyFiltered);
          pageData = sortedAll.slice(offset, offset + historyPageSize);
        } else {
          pageData = historyFiltered;
        }
        renderHistoryList(pageData, historySelectedDate, { total: currentHistoryIncidents.length, skipSort: currentSort === 'urgency' });
        setMapMarkers(pageData, { fit: false, mode: 'history' });
      } else if (liveVisible) {
        const filtered = getFilteredIncidents(currentIncidents);
        renderIncidentList(filtered);
        setMapMarkers(filtered, { fit: false, mode: 'live' });
      }
    }
    
    // Update last update time
    async function updateStatus() {
      try {
        const response = await fetch('api/status');
        const status = await response.json();

        const el = document.getElementById('last-update');

        if (status.centralDate) {
          const prevToday = isoToday;
          isoToday = status.centralDate;
          if (historySelectedDate === prevToday) {
            setHistoryDate(status.centralDate, { load: false });
          } else {
            renderDatePicker();
          }
        }

        // Prefer the upstream Caddo911 "Refreshed at:" timestamp if available.
        if (status.feedRefreshedAt) {
          const tz = status.centralTzAbbr || 'CT';
          el.textContent = `${status.feedRefreshedAt} ${tz}`;
        } else if (status.lastUpdateDisplay) {
          el.textContent = status.lastUpdateDisplay;
        } else if (status.lastScrapeFinishedAt || status.lastUpdate) {
          // Fallback: if the backend didn't provide Central-time strings, show local time.
          const date = new Date(status.lastScrapeFinishedAt || status.lastUpdate);
          el.textContent = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        // Helpful hover text
        if (status.lastUpdateTooltip) {
          el.title = `Server scrape (Central): ${status.lastUpdateTooltip}`;
        } else {
          const scraped = status.lastScrapeFinishedAt || status.lastUpdate;
          el.title = scraped ? `Server scrape: ${new Date(scraped).toLocaleString()}` : '';
        }
        return typeof status.scrapeInterval === 'number' ? status.scrapeInterval : null;
      } catch (error) {
        console.error('Failed to fetch status:', error);
        return null;
      }
    }
    
    // Load history
    async function loadHistory(date) {
      try {
        const offset = (historyPage - 1) * historyPageSize;
        const baseUrl = date
          ? `api/incidents/history?date=${date}`
          : `api/incidents/history`;
        const pageUrl = `${baseUrl}&limit=${historyPageSize}&offset=${offset}`;
        const response = await fetch(pageUrl);
        const data = await response.json();

        let incidents = Array.isArray(data.incidents) ? data.incidents : [];
        let total = Number(data.total || 0);

        if (currentSort === 'urgency' && total > incidents.length) {
          const fullUrl = `${baseUrl}&limit=${total}&offset=0`;
          const fullResponse = await fetch(fullUrl);
          const fullData = await fullResponse.json();
          incidents = Array.isArray(fullData.incidents) ? fullData.incidents : incidents;
          total = Number(fullData.total || total);
        }

        currentHistoryIncidents = incidents;
        historyTotal = total;
        // Only update shared filter visibility from History when the History tab is visible.
        const historyPanel = document.getElementById('history-panel');
        const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');
        if (historyVisible) {
          updateFilterButtonVisibility(currentHistoryIncidents);
        }
        const filteredAll = getFilteredIncidents(currentHistoryIncidents, currentFilter);
        
        // For urgency sort: sort ALL incidents by urgency first, THEN paginate
        let filtered;
        if (currentSort === 'urgency') {
          const sortedAll = sortIncidents(filteredAll);
          filtered = sortedAll.slice(offset, offset + historyPageSize);
        } else {
          filtered = filteredAll;
        }
        
        updateHistoryCount(historyTotal, date);
        updateHistoryPagination();
        // Pass skipSort flag so we don't re-sort already-sorted urgency data
        renderHistoryList(filtered, date, { total: historyTotal, skipSort: currentSort === 'urgency' });

        // Replace map markers with history results when History tab is active
        if (historyVisible) {
          setMapMarkers(filtered, { fit: true, mode: 'history' });
        }
      } catch (error) {
        console.error('Failed to fetch history:', error);
      }
    }

    function updateHistoryCount(total, date) {
      const countWrap = document.getElementById('history-count');
      const countValue = document.getElementById('history-count-value');
      const countLabel = document.getElementById('history-count-label');
      if (!countWrap || !countValue) return;
      const isToday = Boolean(date && date === isoToday);
      if (countLabel) {
        countLabel.textContent = isToday ? 'Today' : 'Incidents';
      }
      countWrap.classList.toggle('today', isToday);
      countWrap.classList.toggle('incidents', !isToday);
      countValue.textContent = total.toString();
      countWrap.classList.remove('hidden');
    }

    function updateHistoryPagination() {
      const pagination = document.getElementById('history-pagination');
      const status = document.getElementById('history-page-status');
      const prev = document.getElementById('history-prev');
      const next = document.getElementById('history-next');
      if (!pagination || !status || !prev || !next) return;

      const totalPages = Math.max(1, Math.ceil(historyTotal / historyPageSize));
      historyPage = Math.min(Math.max(historyPage, 1), totalPages);
      status.textContent = `Page ${historyPage} of ${totalPages}`;
      prev.disabled = historyPage <= 1;
      next.disabled = historyPage >= totalPages;
      pagination.classList.toggle('hidden', totalPages <= 1);
    }

    function renderHistoryList(incidents, date, { total = 0, skipSort = false } = {}) {
      const listEl = document.getElementById('history-list');
      const dateLabel = date
        ? new Date(`${date}T00:00:00`).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' })
        : 'selected date';
      const sorted = skipSort ? incidents : sortIncidents(incidents);

      if (total === 0) {
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="icon">üìã</div>
            <p>No incidents available for</p>
            <p style="font-size: 12px; margin-top: 6px; color: var(--text); font-weight: 600;">${dateLabel}</p>
            <p style="font-size: 11px; margin-top: 10px;">Try another date (or the cache may not include that day yet).</p>
          </div>
        `;
        return;
      }

      if (sorted.length === 0) {
        const hasAgencyFilter = currentFilter !== 'all';
        const hasUrgencyFilter = currentUrgencyFilter !== 'all';
        
        let filterLabelStr = 'incidents';
        if (hasAgencyFilter && hasUrgencyFilter) {
          filterLabelStr = `${urgencyLabel(currentUrgencyFilter)} ${filterLabel(currentFilter)} incidents`;
        } else if (hasAgencyFilter) {
          filterLabelStr = `${filterLabel(currentFilter)} incidents`;
        } else if (hasUrgencyFilter) {
          filterLabelStr = `${urgencyLabel(currentUrgencyFilter)} incidents`;
        }
        
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="icon">üìã</div>
            <p>No ${filterLabelStr} for</p>
            <p style="font-size: 12px; margin-top: 6px; color: var(--text); font-weight: 600;">${dateLabel}</p>
            <p style="font-size: 11px; margin-top: 10px;">Try another filter combination or date.</p>
          </div>
        `;
        return;
      }

      listEl.innerHTML = sorted.map(inc => createIncidentCard(inc, false)).join('');
    }

    // Inline History date picker (no browser-native date input)
    const historyDateBtn = document.getElementById('history-date-btn');
    const historyDateValue = document.getElementById('history-date-value');
    const datePickerEl = document.getElementById('date-picker');

    function pad2(n) {
      return String(n).padStart(2, '0');
    }

    function formatIsoDate(year, month, day) {
      return `${year}-${pad2(month)}-${pad2(day)}`;
    }

    function getCentralIsoDateFallback() {
      try {
        return new Intl.DateTimeFormat('en-CA', {
          timeZone: 'America/Chicago',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        }).format(new Date());
      } catch (error) {
        const d = new Date();
        return formatIsoDate(d.getFullYear(), d.getMonth() + 1, d.getDate());
      }
    }

    let isoToday = getCentralIsoDateFallback();
    let historySelectedDate = isoToday;
    let historyViewMonth = (() => {
      const d = parseISODate(isoToday);
      d.setDate(1);
      return d;
    })();
    const historyCountsByMonth = new Map();

    function monthKeyFromDate(date) {
      return `${date.getFullYear()}-${pad2(date.getMonth() + 1)}`;
    }

    function isoFromParts(year, monthIndex, day) {
      return `${year}-${pad2(monthIndex + 1)}-${pad2(day)}`;
    }

    function parseISODate(iso) {
      const [y, m, d] = iso.split('-').map(Number);
      return new Date(y, (m || 1) - 1, d || 1);
    }

    function getFrequencyClass(count) {
      if (count > 100) return 'freq-high';
      if (count >= 26) return 'freq-medium';
      if (count >= 1) return 'freq-low';
      return '';
    }

    async function loadHistoryCountsForMonth(date) {
      const monthKey = monthKeyFromDate(date);
      if (historyCountsByMonth.has(monthKey)) return;

      try {
        const response = await fetch(`api/incidents/history_counts?month=${monthKey}`);
        if (!response.ok) throw new Error(`History counts request failed: ${response.status}`);
        const data = await response.json();
        const counts = data && typeof data === 'object' ? (data.counts || {}) : {};
        historyCountsByMonth.set(monthKey, counts);
      } catch (error) {
        console.error('Failed to fetch history counts:', error);
        historyCountsByMonth.set(monthKey, {});
      }
    }

    function getHistoryCount(isoDate) {
      const monthKey = isoDate.slice(0, 7);
      const monthCounts = historyCountsByMonth.get(monthKey);
      return Number(monthCounts?.[isoDate] || 0);
    }

    function setHistoryDate(iso, { load = true } = {}) {
      historySelectedDate = iso;
      historyDateValue.textContent = iso;
      const d = parseISODate(iso);
      d.setDate(1);
      historyViewMonth = d;
      historyPage = 1;
      if (load) loadHistory(iso);
      renderDatePicker();
    }

    function toggleDatePicker(forceOpen) {
      const next = typeof forceOpen === 'boolean' ? forceOpen : !datePickerEl.classList.contains('open');
      datePickerEl.classList.toggle('open', next);
      datePickerEl.setAttribute('aria-hidden', String(!next));
      historyDateBtn.setAttribute('aria-expanded', String(next));
      if (next) renderDatePicker();
    }

    function renderDatePicker() {
      if (!datePickerEl.classList.contains('open')) return;

      const year = historyViewMonth.getFullYear();
      const month = historyViewMonth.getMonth();
      const firstDow = new Date(year, month, 1).getDay(); // 0=Sun
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const monthKey = monthKeyFromDate(historyViewMonth);
      const monthCounts = historyCountsByMonth.get(monthKey);

      if (!monthCounts) {
        loadHistoryCountsForMonth(historyViewMonth).then(() => {
          if (datePickerEl.classList.contains('open')) renderDatePicker();
        });
      }

      const monthLabel = historyViewMonth.toLocaleString('en-US', { month: 'long', year: 'numeric' });
      const dows = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

      let html = `
        <div class="dp-header">
          <button type="button" class="dp-nav" data-action="prev" aria-label="Previous month">‚Äπ</button>
          <div class="dp-month">${monthLabel}</div>
          <button type="button" class="dp-nav" data-action="next" aria-label="Next month">‚Ä∫</button>
        </div>
        <div class="dp-grid">
          ${dows.map(d => `<div class="dp-dow">${d}</div>`).join('')}
      `;

      // Leading empties
      for (let i = 0; i < firstDow; i++) {
        html += `<button type="button" class="dp-day empty" tabindex="-1" disabled></button>`;
      }

      for (let day = 1; day <= daysInMonth; day++) {
        const iso = isoFromParts(year, month, day);
        const isSelected = iso === historySelectedDate;
        const isToday = iso === isoToday;
        const count = monthCounts ? getHistoryCount(iso) : 0;
        const freqClass = getFrequencyClass(count);
        const cls = [
          'dp-day',
          freqClass,
          isSelected ? 'selected' : '',
          isToday ? 'today' : ''
        ].filter(Boolean).join(' ');
        const label = count > 0 ? `${count} incident${count === 1 ? '' : 's'}` : 'No incidents';
        html += `<button type="button" class="${cls}" data-date="${iso}" title="${label}">${day}</button>`;
      }

      // Trailing empties to fill last row (up to 42 day cells + 7 dows)
      const totalCells = firstDow + daysInMonth;
      const trailing = (7 - (totalCells % 7)) % 7;
      for (let i = 0; i < trailing; i++) {
        html += `<button type="button" class="dp-day empty" tabindex="-1" disabled></button>`;
      }

      html += `</div>`;
      datePickerEl.innerHTML = html;
    }

    historyDateBtn.addEventListener('click', () => toggleDatePicker());

    datePickerEl.addEventListener('click', (e) => {
      const action = e.target.closest('button[data-action]')?.dataset.action;
      if (action === 'prev') {
        historyViewMonth = new Date(historyViewMonth.getFullYear(), historyViewMonth.getMonth() - 1, 1);
        renderDatePicker();
        return;
      }
      if (action === 'next') {
        historyViewMonth = new Date(historyViewMonth.getFullYear(), historyViewMonth.getMonth() + 1, 1);
        renderDatePicker();
        return;
      }

      const date = e.target.closest('button[data-date]')?.dataset.date;
      if (date) {
        setHistoryDate(date, { load: true });
        toggleDatePicker(false);
      }
    });

    // History pagination
    const historyPrev = document.getElementById('history-prev');
    const historyNext = document.getElementById('history-next');

    function scrollHistoryListToTop() {
      const historyList = document.getElementById('history-list');
      if (historyList) historyList.scrollTop = 0;
    }

    historyPrev?.addEventListener('click', () => {
      if (historyPage <= 1) return;
      historyPage -= 1;
      loadHistory(historySelectedDate);
      scrollHistoryListToTop();
    });

    historyNext?.addEventListener('click', () => {
      const totalPages = Math.max(1, Math.ceil(historyTotal / historyPageSize));
      if (historyPage >= totalPages) return;
      historyPage += 1;
      loadHistory(historySelectedDate);
      scrollHistoryListToTop();
    });

    // Close date picker when clicking outside of it
    document.addEventListener('click', (e) => {
      if (!datePickerEl.classList.contains('open')) return;
      if (datePickerEl.contains(e.target) || historyDateBtn.contains(e.target)) return;
      toggleDatePicker(false);
    });
    
    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        const tabName = tab.dataset.tab;
        document.getElementById('live-panel').classList.toggle('hidden', tabName !== 'live');
        document.getElementById('history-panel').classList.toggle('hidden', tabName !== 'history');
        
        if (tabName === 'history') {
          mapMode = 'history';
          // Clear live markers immediately; history will repopulate after fetch
          setMapMarkers([], { mode: 'history' });
          // Make sure the date UI is initialized and load that date's cache
          setHistoryDate(historySelectedDate, { load: true });
          toggleDatePicker(false);
        } else {
          mapMode = 'live';
          const countWrap = document.getElementById('history-count');
          if (countWrap) countWrap.classList.add('hidden');
          // Live tab: make filter visibility reflect the active feed immediately
          updateFilterButtonVisibility(currentIncidents);
          // Render live markers immediately from the last-known active incidents
          setMapMarkers(getFilteredIncidents(currentIncidents), { fit: false, mode: 'live' });
          toggleDatePicker(false);
        }
      });
    });
    
    // Agency filter button handlers
    document.querySelectorAll('.filter-group[data-filter-type="agency"] .filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        applyAgencyFilter(btn.dataset.filter);
      });
    });

    // Urgency filter button handlers
    document.querySelectorAll('.filter-group[data-filter-type="urgency"] .filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        applyUrgencyFilter(btn.dataset.urgency);
      });
    });

    // Sort control
    const sortToggle = document.getElementById('sort-toggle');
    const sortMenu = document.getElementById('sort-menu');

    function setSort(mode) {
      currentSort = mode === 'urgency' ? 'urgency' : 'recent';
      sortMenu?.querySelectorAll('.sort-option').forEach(option => {
        option.classList.toggle('active', option.dataset.sort === currentSort);
      });

      const livePanel = document.getElementById('live-panel');
      const historyPanel = document.getElementById('history-panel');
      const liveVisible = livePanel && !livePanel.classList.contains('hidden');
      const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');

      if (historyVisible) {
        const historyFiltered = getFilteredIncidents(currentHistoryIncidents);
        const offset = (historyPage - 1) * historyPageSize;
        let pageData;
        if (currentSort === 'urgency') {
          const sortedAll = sortIncidents(historyFiltered);
          pageData = sortedAll.slice(offset, offset + historyPageSize);
        } else {
          pageData = historyFiltered;
        }
        renderHistoryList(pageData, historySelectedDate, { total: currentHistoryIncidents.length, skipSort: currentSort === 'urgency' });
      } else if (liveVisible) {
        const filtered = getFilteredIncidents(currentIncidents);
        renderIncidentList(filtered);
      }
    }

    function toggleSortMenu(forceOpen) {
      if (!sortMenu || !sortToggle) return;
      const next = typeof forceOpen === 'boolean' ? forceOpen : !sortMenu.classList.contains('open');
      sortMenu.classList.toggle('open', next);
      sortMenu.setAttribute('aria-hidden', String(!next));
      sortToggle.setAttribute('aria-expanded', String(next));
    }

    sortToggle?.addEventListener('click', () => toggleSortMenu());
    sortMenu?.addEventListener('click', (e) => {
      const mode = e.target.closest('button[data-sort]')?.dataset.sort;
      if (!mode) return;
      setSort(mode);
      toggleSortMenu(false);
    });

    document.addEventListener('click', (e) => {
      if (!sortMenu?.classList.contains('open')) return;
      if (sortMenu.contains(e.target) || sortToggle?.contains(e.target)) return;
      toggleSortMenu(false);
    });
    
    // Initialize History date UI (default to today)
    setHistoryDate(isoToday, { load: false });
    
    // Polling interval (ms). Keep at least 60s to be gentle.
    let pollIntervalMs = 60000;

    // Initial load
    loadParishOutline();
    updateIncidents();
    updateStatus();
    
    // Poll for updates with dynamic interval from /api/status.
    // This keeps chatter low and aligned with backend scrape cadence.
    async function pollLoop() {
      await updateIncidents();
      const nextInterval = await updateStatus();
      if (typeof nextInterval === 'number' && Number.isFinite(nextInterval)) {
        pollIntervalMs = Math.max(60000, Math.round(nextInterval));
      }
      setTimeout(pollLoop, pollIntervalMs);
    }

    setTimeout(pollLoop, pollIntervalMs);
  </script>
</body>
</html>
