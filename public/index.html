<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CADDO 911 LIVE</title>
  <link rel="icon" href="images/caddo911logo.png" type="image/png">
  <link rel="icon" href="images/caddo911logo.webp" type="image/webp">
  <link rel="apple-touch-icon" href="images/caddo911logo.png">
  <meta property="og:title" content="Caddo 911 Live Feed">
  <meta property="og:description" content="Live emergency incident map for Caddo Parish, Louisiana.">
  <meta property="og:image" content="images/caddo911logo.png">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="images/caddo911logo.png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header class="header">
    <div class="logo">
      <picture class="logo-icon">
        <source srcset="images/caddo911logo.webp" type="image/webp">
        <img src="images/caddo911logo.png" alt="Caddo 911" class="logo-icon-img">
      </picture>
      <div class="logo-text">
        <h1>CADDO PARISH</h1>
        <p>Emergency Dispatch Live Feed</p>
      </div>
    </div>
    <div class="status-bar">
      <div class="status-item">
        <span class="status-label">Status</span>
        <span class="status-value live"><span class="live-dot"></span>LIVE</span>
      </div>
      <div class="status-item">
        <span class="status-label">Last Update</span>
        <span class="status-value" id="last-update">--:--</span>
      </div>
      <div class="status-item">
        <span class="status-label">Active</span>
        <span class="status-value" id="active-count">0</span>
      </div>
      <div class="status-item">
        <span class="status-label">Map Theme</span>
        <button class="map-theme-toggle" id="map-theme-toggle" aria-pressed="true" title="Toggle map theme">
          <span class="map-theme-icon" aria-hidden="true">‚òÄÔ∏è</span>
        </button>
      </div>
      <button class="info-btn" onclick="toggleInfoPanel()" title="About">i</button>
    </div>
  </header>
  
  <div class="info-modal" id="info-modal" aria-hidden="true">
    <div class="modal-backdrop" role="presentation"></div>
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-label="About Caddo 911 Live">
      <button class="modal-close" type="button" aria-label="Close" id="info-close">√ó</button>
      <div class="info-content">
        <div class="info-hero">
          <img src="https://www.vincentlarkin.com/images/site-emblem.png" alt="Vincent Larkin emblem" class="info-logo">
          <div>
            <h3>Caddo 911 Live Feed</h3>
            <p style="margin-bottom: 6px;">Real-time emergency incident tracker for Caddo Parish, Louisiana.</p>
            <p style="margin-bottom: 0;">Built and maintained by Vincent Larkin.</p>
          </div>
        </div>
        
        <div class="notion-callout" role="note" aria-label="Disclaimer">
          <div class="icon" aria-hidden="true">i</div>
          <p>
            This website is a citizen-run project and is not affiliated with or endorsed by the State of Louisiana, any Louisiana state agency, Caddo Parish, or any Caddo Parish department or technology system. No state or parish funds were used to create or operate this project. <strong>$0.00</strong> of public funding has been spent on this website.
          </p>
        </div>
        
        <div class="info-links">
          <a href="https://github.com/vincentlarkin" target="_blank" class="info-link">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
            GitHub
          </a>
          <a href="https://vincentlarkin.com" target="_blank" class="info-link">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
            Website
          </a>
          <a href="https://linkedin.com/in/vincentwlarkin" target="_blank" class="info-link">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
            LinkedIn
          </a>
        </div>
        <p class="info-credit">Created by Vincent Larkin</p>
      </div>
    </div>
  </div>
  
  <main class="main-container">
    <div class="map-container">
      <div id="map"></div>
      <div class="legend-container" id="legend-container">
        <div class="map-overlay" id="map-legend">
          <button class="legend-collapse" id="legend-collapse" type="button" aria-expanded="true" aria-label="Collapse legend" title="Collapse legend">‚óÄ</button>
          
          <!-- Collapsed "handle" view (drawer-closed) -->
          <div class="legend-mini" aria-hidden="true">
            <div class="dot-stack">
              <span class="dot" style="background: var(--red);"></span>
              <span class="dot" style="background: var(--amber);"></span>
              <span class="dot" style="background: var(--blue);"></span>
            </div>
          </div>
          
          <!-- Expanded content -->
          <div class="legend-content">
            <h3>Legend</h3>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--red)"></div>
              <span>High severity</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--amber)"></div>
              <span>Medium severity</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--blue)"></div>
              <span>Low severity</span>
            </div>
            <div style="margin-top: 10px; font-size: 10px; color: var(--text-dim); line-height: 1.4;">
              Colors = severity. Use the sidebar filters to limit by agency.
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <aside class="sidebar">
      <div class="tabs">
        <button class="tab active" data-tab="live">Live</button>
        <button class="tab" data-tab="history">History</button>
      </div>

      <!-- Shared filters (apply to Live + History lists) -->
      <div class="filter-bar">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="cadfd">
          <img src="images/cfd-fire.png" alt="CAD-FD/EMS" class="filter-logo">
          <span>CAD-FD/EMS</span>
        </button>
        <button class="filter-btn" data-filter="shvfd">
          <img src="images/sfd-fire.png" alt="SHVFD" class="filter-logo">
          <span>SHVFD</span>
        </button>
        <button class="filter-btn" data-filter="police">
          <img src="images/spd-police.png" alt="Police" class="filter-logo">
          <span>Police</span>
        </button>
        <button class="filter-btn" data-filter="sheriff">
          <img src="images/cso-sheriff.png" alt="Sheriff" class="filter-logo">
          <span>Sheriff</span>
        </button>
        <div class="history-count hidden" id="history-count">
          <span>Incident total:</span>
          <strong id="history-count-value">0</strong>
        </div>
      </div>
      
      <div id="live-panel">
        <div class="incident-list" id="incident-list"></div>
        <div class="stats-panel">
          <div class="stats-grid">
            <div class="stat-box">
              <div class="stat-number" id="stat-active">0</div>
              <div class="stat-label">Active</div>
            </div>
            <div class="stat-box">
              <div class="stat-number" id="stat-today">0</div>
              <div class="stat-label">Today</div>
            </div>
            <div class="stat-box">
              <div class="stat-number" id="stat-total">0</div>
              <div class="stat-label">Total</div>
            </div>
          </div>
        </div>
      </div>
      
      <div id="history-panel" class="hidden">
        <div class="history-controls">
          <button type="button" id="history-date-btn" class="date-input" aria-expanded="false" aria-controls="date-picker">
            <div class="date-input-left">
              <div class="date-input-label">History date</div>
              <div class="date-input-value" id="history-date-value">----</div>
            </div>
            <svg class="date-input-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M7 11h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM7 15h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z"/>
              <path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"/>
            </svg>
          </button>
          <div class="date-picker" id="date-picker" aria-hidden="true"></div>
        </div>
        <div class="incident-list" id="history-list"></div>
      </div>
    </aside>
  </main>
  
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Initialize map centered on Shreveport/Caddo Parish
    const map = L.map('map', {
      zoomControl: false,
      minZoom: 7,
      maxZoom: 19,
      worldCopyJump: true
    }).setView([32.5252, -93.7502], 11);
    
    // Keep view constrained to a few-state window around Louisiana/Texas/Arkansas
    const southWest = L.latLng(29.0, -98.0);
    const northEast = L.latLng(34.5, -90.0);
    map.setMaxBounds(L.latLngBounds(southWest, northEast));
    
    // Dark basemap (keeps the UI in dark mode) with a separate label overlay for readability.
    // Base (no labels) in its own pane so we can color-grade it without affecting labels.
    map.createPane('base');
    map.getPane('base').classList.add('leaflet-base-pane');
    map.getPane('base').style.zIndex = 200;

    map.createPane('labels');
    map.getPane('labels').classList.add('leaflet-labels-pane');
    map.getPane('labels').style.zIndex = 650;
    map.getPane('labels').style.pointerEvents = 'none';

    // Tile layers for light + dark themes
    const lightBase = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
      pane: 'base',
      attribution: '&copy; OpenStreetMap &copy; CARTO',
      subdomains: 'abcd',
      maxZoom: 19,
      crossOrigin: true
    });
    const lightLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
      pane: 'labels',
      subdomains: 'abcd',
      maxZoom: 19,
      opacity: 0.65,
      crossOrigin: true
    });
    const osmFallbackTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      pane: 'base',
      attribution: '&copy; OpenStreetMap contributors',
      maxZoom: 19,
      subdomains: 'abc',
      crossOrigin: true
    });
    const tileLayers = {
      dark: {
        base: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
          pane: 'base',
          attribution: '&copy; OpenStreetMap &copy; CARTO',
          subdomains: 'abcd',
          maxZoom: 19
        }),
        labels: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', {
          pane: 'labels',
          subdomains: 'abcd',
          maxZoom: 19,
          opacity: 1
        })
      },
      light: {
        base: lightBase,
        labels: lightLabels
      }
    };
    
    let mapTheme = 'light';
    
    function setMapTheme(theme) {
      mapTheme = theme === 'dark' ? 'dark' : 'light';
      // Remove any existing layers
      Object.values(tileLayers.dark).forEach(layer => { if (map.hasLayer(layer)) map.removeLayer(layer); });
      Object.values(tileLayers.light).forEach(layer => { if (map.hasLayer(layer)) map.removeLayer(layer); });
      
      const layersToAdd = tileLayers[mapTheme];
      Object.values(layersToAdd).forEach(layer => layer.addTo(map));
      
      // If light tiles fail, fall back to standard OSM automatically
      if (mapTheme === 'light' && layersToAdd.base === lightBase) {
        const onError = () => {
          if (map.hasLayer(lightBase)) {
            map.removeLayer(lightBase);
            osmFallbackTiles.addTo(map);
            tileLayers.light.base = osmFallbackTiles;
            // drop labels to avoid mismatch
            if (map.hasLayer(lightLabels)) map.removeLayer(lightLabels);
            delete tileLayers.light.labels;
          }
        };
        lightBase.once('tileerror', onError);
      }
      
      document.body.classList.toggle('map-light', mapTheme === 'light');
      document.body.classList.toggle('map-dark', mapTheme === 'dark');
      
      const toggle = document.getElementById('map-theme-toggle');
      if (toggle) {
        const iconEl = toggle.querySelector('.map-theme-icon');
        if (iconEl) iconEl.textContent = mapTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
        toggle.setAttribute('aria-pressed', String(mapTheme === 'light'));
      }
    }
    
    // Default to light mode
    setMapTheme('light');
    
    // Legend drawer (auto-collapse on narrow screens)
    const legendContainer = document.getElementById('legend-container');
    const legendPanel = document.getElementById('map-legend');
    const legendCollapse = document.getElementById('legend-collapse');
    let legendExpandedHeight = null;
    
    function measureLegendExpandedHeight() {
      if (!legendPanel) return;
      // Ensure height is auto for measurement
      legendPanel.style.height = '';
      legendExpandedHeight = legendPanel.offsetHeight;
    }
    
    function setLegendCollapsed(collapsed) {
      if (!legendContainer || !legendPanel) return;
      legendContainer.classList.toggle('collapsed', collapsed);
      
      // Keep the same height (drawer closes horizontally only)
      if (collapsed && legendExpandedHeight) {
        legendPanel.style.height = `${legendExpandedHeight}px`;
      } else {
        legendPanel.style.height = '';
        // When expanding, refresh measured height for the current layout
        requestAnimationFrame(measureLegendExpandedHeight);
      }
      
      if (legendCollapse) {
        legendCollapse.setAttribute('aria-expanded', String(!collapsed));
        legendCollapse.textContent = collapsed ? '‚ñ∂' : '‚óÄ';
        legendCollapse.title = collapsed ? 'Expand legend' : 'Collapse legend';
        legendCollapse.setAttribute('aria-label', collapsed ? 'Expand legend' : 'Collapse legend');
      }
    }
    
    // Initial measurement (expanded state), then optionally collapse for smaller screens
    measureLegendExpandedHeight();
    if (window.innerWidth < 960) setLegendCollapsed(true);
    
    legendCollapse?.addEventListener('click', () => {
      const isCollapsed = legendContainer?.classList.contains('collapsed');
      setLegendCollapsed(!isCollapsed);
    });
    
    // Keep measurements accurate if the layout changes
    window.addEventListener('resize', () => {
      if (!legendContainer?.classList.contains('collapsed')) {
        measureLegendExpandedHeight();
      }
    });
    
    // Add zoom control to bottom right
    L.control.zoom({ position: 'bottomright' }).addTo(map);
    
    const mapThemeToggle = document.getElementById('map-theme-toggle');
    if (mapThemeToggle) {
      mapThemeToggle.addEventListener('click', () => {
        setMapTheme(mapTheme === 'light' ? 'dark' : 'light');
      });
    }
    
    // Store markers
    const markers = new Map();
    let currentIncidents = [];
    let currentHistoryIncidents = [];
    let currentFilter = 'all';
    let mapMode = 'live'; // 'live' | 'history'
    
    // Agency color mapping
    function getAgencyColor(agency) {
      if (agency.startsWith('CFD') || agency.startsWith('SFD')) return '#ff6b35'; // Fire
      if (agency === 'EMS' || agency.includes('EMS')) return '#ff3b6b'; // Medical
      if (agency === 'SPD') return '#3b8bff'; // Police
      if (agency === 'CSO') return '#9b59b6'; // Sheriff
      return '#ffb830'; // Other
    }
    
    function getAgencyClass(agency) {
      if (agency.startsWith('CFD') || agency.startsWith('SFD')) return 'fire';
      if (agency === 'EMS' || agency.includes('EMS')) return 'medical';
      if (agency === 'SPD') return 'police';
      if (agency === 'CSO') return 'sheriff';
      return 'other';
    }
    
    // Severity classification (meaningful colors)
    // - high: life safety / violence / fire / serious traffic
    // - medium: theft / hazards / accidents
    // - low: follow-up / reports / citizen assist
    function _normalizeDesc(description) {
      return String(description || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function _includesAny(text, terms) {
      for (const t of terms) {
        if (text.includes(t)) return true;
      }
      return false;
    }

    function getSeverity(incident) {
      const d = _normalizeDesc(incident?.description);
      const agency = String(incident?.agency || '').toUpperCase();

      // Explicit low-priority / administrative / follow-up type calls
      const LOW = [
        'follow up', 'followup', 'follow', 'investigation', 'report', 'information',
        'citizen assist', 'citizen assistance', 'assist citizen', 'civil',
        'welfare check', 'wellness check', 'property check', 'extra patrol', 'directed patrol',
        'noise', 'complaint', 'parking', 'traffic control',
        'lost property', 'found property',
      ];

      // High-severity life safety / violence / weapons / fire / critical medical
      const HIGH = [
        // Violence / weapons
        'shots fired', 'shooting', 'shot fired', 'gun', 'armed', 'weapon',
        'stabbing', 'stab', 'knife',
        'assault', 'battery', 'domestic', 'fight',
        'robbery', 'home invasion', 'kidnap', 'hostage',
        'homicide', 'murder', 'rape', 'sexual',
        // Fire
        'structure fire', 'house fire', 'apartment fire', 'building fire',
        'fire', 'smoke', 'explosion',
        // Medical
        'medical', 'ems', 'unconscious', 'not breathing', 'difficulty breathing', 'choking',
        'overdose', 'cardiac', 'heart', 'stroke', 'seizure',
        // Traffic (serious)
        'hit and run', 'hit run', 'injury accident', 'accident with injuries', 'fatal', 'entrap', 'rollover',
      ];

      // Medium-severity incidents (default bucket if not high/low)
      const MEDIUM = [
        // Theft / property crime
        'stolen', 'theft', 'burglary', 'break in', 'breaking entering', 'shoplift', 'vandal',
        // Traffic / hazard
        'accident', 'crash', 'wreck', 'collision', 'mvc', 'mva',
        'road hazard', 'debris', 'disabled vehicle',
        // Animals
        'loose livestock', 'livestock', 'loose animal', 'animal in roadway', 'cow', 'horse',
        // General police calls
        'disturbance', 'suspicious', 'trespass', 'harassment', 'fraud', 'alarm',
      ];

      // Special-cases: "minor accident" should not be treated like a high-priority crime call.
      if (d.includes('minor accident') || d.includes('minor crash') || d.includes('fender bender')) {
        return 'low';
      }

      if (_includesAny(d, HIGH)) return 'high';
      if (_includesAny(d, LOW)) return 'low';
      if (_includesAny(d, MEDIUM)) return 'medium';

      // If we can't classify: default to medium (safer than understating severity).
      // EMS agency tends to be life-safety oriented.
      if (agency === 'EMS' || agency.includes('EMS')) {
        return 'high';
      }
      return 'medium';
    }

    function getSeverityClass(sev) {
      return sev === 'high' ? 'sev-high' : sev === 'low' ? 'sev-low' : 'sev-medium';
    }

    function getSeverityColor(sev) {
      if (sev === 'high') return '#ff3b3b';
      if (sev === 'low') return '#3b8bff';
      return '#ffb830';
    }
    
    // Filter logic - matches agency codes to filter categories
    function matchesFilter(incident, filter) {
      if (filter === 'all') return true;
      
      const agency = incident.agency.toUpperCase();
      
      switch (filter) {
        case 'cadfd':
          // Caddo Fire Districts + Caddo EMS events live on CFD_* pages
          return agency.startsWith('CFD');
        case 'shvfd':
          // Shreveport Fire Dept live on SFD_* pages
          return agency.startsWith('SFD');
        case 'police':
          // SPD = Shreveport Police Dept
          return agency === 'SPD' || agency.includes('POLICE');
        case 'sheriff':
          // CSO = Caddo Sheriff's Office
          return agency === 'CSO' || agency.includes('SHERIFF');
        default:
          return true;
      }
    }
    
    function filterLabel(filter) {
      switch (filter) {
        case 'cadfd': return 'CAD-FD/EMS';
        case 'shvfd': return 'SHVFD';
        case 'police': return 'police';
        case 'sheriff': return 'sheriff';
        default: return filter;
      }
    }

    function getFilteredIncidents(incidents, filter) {
      return incidents.filter(inc => matchesFilter(inc, filter));
    }

    // Hide fire-related filters when there are zero matching incidents.
    // This avoids confusing cases where users click a filter that has no data.
    function updateFilterButtonVisibility(baseIncidents) {
      const counts = {
        cadfd: 0,
        shvfd: 0,
      };

      for (const inc of baseIncidents || []) {
        if (matchesFilter(inc, 'cadfd')) counts.cadfd += 1;
        if (matchesFilter(inc, 'shvfd')) counts.shvfd += 1;
      }

      // Always show filter "tabs" even when they have 0 incidents.
      // Visually dim them so users understand they‚Äôre empty, but still allow clicking
      // (the list will show a "No incidents" message).
      document.querySelectorAll('.filter-btn').forEach(btn => {
        const f = btn.dataset.filter;
        if (f === 'cadfd' || f === 'shvfd') {
          btn.classList.toggle('empty', (counts[f] || 0) === 0);
        } else {
          btn.classList.remove('empty');
        }
      });

      // Keep active state consistent (especially after fallback)
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === currentFilter);
      });
    }
    
    function _stringHash(str) {
      // Stable 32-bit hash for deterministic marker shapes per incident
      let h = 2166136261;
      const s = String(str || '');
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    function _incidentSeed(incident) {
      return _stringHash(incident?.hash || incident?.id || '');
    }

    function _triangleLatLngs(lat, lng, sizeMeters, seed) {
      // Small equilateral-ish triangle around a center point, rotated deterministically.
      const base = [
        [0, 1],
        [-0.866, -0.5],
        [0.866, -0.5],
      ];
      const angle = ((seed % 360) * Math.PI) / 180;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      const latRad = (lat * Math.PI) / 180;
      const mPerDegLat = 111320;
      const mPerDegLng = 111320 * Math.cos(latRad);

      return base.map(([x, y]) => {
        const rx = x * cos - y * sin;
        const ry = x * sin + y * cos;
        const dLat = (ry * sizeMeters) / mPerDegLat;
        const dLng = (rx * sizeMeters) / (mPerDegLng || 1);
        return [lat + dLat, lng + dLng];
      });
    }

    function _geocodeTriangleSizeMeters(incident, mode) {
      const src = String(incident?.geocode_source || '').toLowerCase();
      const q = String(incident?.geocode_quality || '').toLowerCase();

      // Defaults: slightly generalized even for "good" geocodes (avoids false precision).
      let size = mode === 'history' ? 70 : 85;

      if (src === 'fallback' || q === 'fallback' || q === 'city-only') {
        size = mode === 'history' ? 220 : 260;
      } else if (q === 'cross-only') {
        size = mode === 'history' ? 160 : 190;
      } else if (q === 'street-only') {
        size = mode === 'history' ? 140 : 170;
      } else if (q === 'street+cross') {
        size = mode === 'history' ? 90 : 110;
      } else if (q === 'intersection-2') {
        size = mode === 'history' ? 65 : 80;
      }

      return size;
    }

    function googleMapsUrl(lat, lng) {
      const q = `${Number(lat).toFixed(6)},${Number(lng).toFixed(6)}`;
      return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(q)}`;
    }

    // Create custom marker (triangle area instead of pinpoint dot)
    function createMarker(incident, { mode = 'live' } = {}) {
      const sev = getSeverity(incident);
      const color = getSeverityColor(sev);
      
      const locationParts = [];
      if (incident.street) locationParts.push(incident.street);
      if (incident.cross_streets) locationParts.push(incident.cross_streets);
      const locationStr = locationParts.join(' @ ') || 'Unknown';

      const seed = _incidentSeed(incident);
      const sizeMeters = _geocodeTriangleSizeMeters(incident, mode);
      const points = _triangleLatLngs(incident.latitude, incident.longitude, sizeMeters, seed);
      const gmaps = googleMapsUrl(incident.latitude, incident.longitude);
      
      const marker = L.polygon(points, {
        color,
        weight: mode === 'history' ? 1 : 1.2,
        opacity: 0.9,
        fillColor: color,
        fillOpacity: mode === 'history' ? 0.18 : 0.28,
      })
        // Right-click ‚Üí open in Google Maps (useful on desktop)
        .on('contextmenu', () => {
          window.open(gmaps, '_blank', 'noopener,noreferrer');
        })
        .bindPopup(`
          <div class="popup-content">
            <div class="popup-title">${incident.description}</div>
            <div class="popup-detail">üìç ${locationStr}</div>
            <div class="popup-detail">üïê ${formatTime(incident.time)}</div>
            <div class="popup-detail">üö® ${incident.agency} ‚Ä¢ ${incident.units} unit(s)</div>
            <div class="popup-detail">‚ö†Ô∏è Severity: ${sev.toUpperCase()}</div>
            <a class="popup-link" href="${gmaps}" target="_blank" rel="noopener noreferrer">Open in Google Maps</a>
          </div>
        `);
      
      return marker;
    }

    // Replace map markers with the given incident set (used for Live and History modes)
    function setMapMarkers(incidents, { fit = false, mode = mapMode } = {}) {
      const nextIds = new Set((incidents || []).map(i => i.id));

      // Remove markers not in the next set
      markers.forEach((marker, id) => {
        if (!nextIds.has(id)) {
          if (map.hasLayer(marker)) map.removeLayer(marker);
          markers.delete(id);
        }
      });

      // Add missing markers
      (incidents || []).forEach(incident => {
        if (!incident || incident.latitude == null || incident.longitude == null) return;
        if (!markers.has(incident.id)) {
          const marker = createMarker(incident, { mode });
          marker.addTo(map);
          markers.set(incident.id, marker);
        } else {
          const marker = markers.get(incident.id);
          if (marker && !map.hasLayer(marker)) marker.addTo(map);
        }
      });

      if (fit && incidents && incidents.length > 0) {
        try {
          const bounds = L.latLngBounds(incidents.map(i => [i.latitude, i.longitude]));
          map.fitBounds(bounds, { padding: [50, 50], maxZoom: 14 });
        } catch (e) {
          // ignore fit errors
        }
      }
    }
    
    // Format time
    function formatTime(time) {
      if (!time) return '--:--';
      const str = time.toString().padStart(4, '0');
      return `${str.slice(0, 2)}:${str.slice(2)}`;
    }
    
    // Create incident card
    function createIncidentCard(incident, isNew = false) {
      const sev = getSeverity(incident);
      const sevClass = getSeverityClass(sev);
      
      return `
        <div class="incident-card ${sevClass} ${isNew ? 'new' : ''}" 
             data-id="${incident.id}"
             onclick="focusIncident(${incident.latitude}, ${incident.longitude})">
          <div class="incident-header">
            <span class="incident-type">${incident.description}</span>
            <span class="incident-time">${formatTime(incident.time)}</span>
          </div>
          <div class="incident-location">
            üìç ${[incident.street, incident.cross_streets].filter(Boolean).join(' @ ') || 'Unknown'}
          </div>
          <div class="incident-meta">
            <span class="incident-agency ${sevClass}" title="Severity: ${sev.toUpperCase()}">${incident.agency}</span>
            <span class="incident-units">${sev.toUpperCase()} ‚Ä¢ ${incident.units} unit(s) ‚Ä¢ ${incident.municipality}</span>
          </div>
        </div>
      `;
    }
    
    // Focus on incident on map
    window.focusIncident = function(lat, lng) {
      map.flyTo([lat, lng], 15, { duration: 0.5 });
    };
    
    // Info modal
    const infoModal = document.getElementById('info-modal');
    const infoClose = document.getElementById('info-close');
    
    window.toggleInfoPanel = function(forceOpen) {
      if (!infoModal) return;
      const next = typeof forceOpen === 'boolean' ? forceOpen : !infoModal.classList.contains('open');
      infoModal.classList.toggle('open', next);
      infoModal.setAttribute('aria-hidden', String(!next));
      document.body.classList.toggle('modal-open', next);
    };
    
    infoClose?.addEventListener('click', () => toggleInfoPanel(false));
    infoModal?.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-backdrop')) toggleInfoPanel(false);
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && infoModal?.classList.contains('open')) toggleInfoPanel(false);
    });
    
    // Update incidents
    async function updateIncidents() {
      try {
        const response = await fetch('api/incidents/active');
        const allIncidents = await response.json();
        
        // Store all incidents
        currentIncidents = allIncidents;

        // Only update shared filter visibility from the active feed when the Live tab is visible.
        // Otherwise History's filter visibility would get overridden every poll.
        const livePanel = document.getElementById('live-panel');
        const liveVisible = livePanel && !livePanel.classList.contains('hidden');
        if (liveVisible) updateFilterButtonVisibility(allIncidents);
        
        // Apply current filter
        const incidents = getFilteredIncidents(allIncidents, currentFilter);
        
        // Update counts
        document.getElementById('active-count').textContent = allIncidents.length;

        // If we're not on the Live tab, don't touch the map/list (History owns the map).
        if (!liveVisible) return;
        
        // Update map + list (filtered)
        setMapMarkers(incidents, { mode: 'live' });
        renderIncidentList(incidents);
        
      } catch (error) {
        console.error('Failed to fetch incidents:', error);
      }
    }
    
    // Render the incident list
    function renderIncidentList(incidents) {
      const listEl = document.getElementById('incident-list');
      if (incidents.length === 0) {
        const label = currentFilter === 'all' ? 'active' : filterLabel(currentFilter);
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="icon">üì°</div>
            <p>No ${label} incidents</p>
            <p style="font-size: 11px; margin-top: 10px;">${currentFilter === 'all' ? 'Waiting for data...' : 'Try a different filter'}</p>
          </div>
        `;
      } else {
        listEl.innerHTML = incidents.map(inc => createIncidentCard(inc, false)).join('');
      }
    }
    
    // Apply filter and update display
    function applyFilter(filter) {
      currentFilter = filter;
      
      // Update filter button states
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
      });

      const livePanel = document.getElementById('live-panel');
      const historyPanel = document.getElementById('history-panel');
      const liveVisible = livePanel && !livePanel.classList.contains('hidden');
      const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');

      if (historyVisible) {
        const historyFiltered = getFilteredIncidents(currentHistoryIncidents, filter);
        renderHistoryList(historyFiltered, historySelectedDate, { total: currentHistoryIncidents.length });
        setMapMarkers(historyFiltered, { fit: false, mode: 'history' });
      } else if (liveVisible) {
        const filtered = getFilteredIncidents(currentIncidents, filter);
        renderIncidentList(filtered);
        setMapMarkers(filtered, { fit: false, mode: 'live' });
      }
    }
    
    // Update stats
    async function updateStats() {
      try {
        const response = await fetch('api/stats');
        const stats = await response.json();
        
        document.getElementById('stat-active').textContent = stats.active;
        document.getElementById('stat-today').textContent = stats.today;
        document.getElementById('stat-total').textContent = stats.total;
        
      } catch (error) {
        console.error('Failed to fetch stats:', error);
      }
    }
    
    // Update last update time
    async function updateStatus() {
      try {
        const response = await fetch('api/status');
        const status = await response.json();

        const el = document.getElementById('last-update');

        // Prefer the upstream Caddo911 "Refreshed at:" timestamp if available.
        if (status.feedRefreshedAt) {
          const tz = status.centralTzAbbr || 'CT';
          el.textContent = `${status.feedRefreshedAt} ${tz}`;
        } else if (status.lastUpdateDisplay) {
          el.textContent = status.lastUpdateDisplay;
        } else if (status.lastScrapeFinishedAt || status.lastUpdate) {
          // Fallback: if the backend didn't provide Central-time strings, show local time.
          const date = new Date(status.lastScrapeFinishedAt || status.lastUpdate);
          el.textContent = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        // Helpful hover text
        if (status.lastUpdateTooltip) {
          el.title = `Server scrape (Central): ${status.lastUpdateTooltip}`;
        } else {
          const scraped = status.lastScrapeFinishedAt || status.lastUpdate;
          el.title = scraped ? `Server scrape: ${new Date(scraped).toLocaleString()}` : '';
        }
      } catch (error) {
        console.error('Failed to fetch status:', error);
      }
    }
    
    // Load history
    async function loadHistory(date) {
      try {
        const url = date ? `api/incidents/history?date=${date}&limit=200` : 'api/incidents/history?limit=200';
        const response = await fetch(url);
        const data = await response.json();

        currentHistoryIncidents = Array.isArray(data.incidents) ? data.incidents : [];
        // Only update shared filter visibility from History when the History tab is visible.
        const historyPanel = document.getElementById('history-panel');
        const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');
        if (historyVisible) {
          updateFilterButtonVisibility(currentHistoryIncidents);
        }
        const filtered = getFilteredIncidents(currentHistoryIncidents, currentFilter);
        updateHistoryCount(currentHistoryIncidents.length, date);
        renderHistoryList(filtered, date, { total: currentHistoryIncidents.length });

        // Replace map markers with history results when History tab is active
        if (historyVisible) {
          setMapMarkers(filtered, { fit: true, mode: 'history' });
        }
      } catch (error) {
        console.error('Failed to fetch history:', error);
      }
    }

    function updateHistoryCount(total, date) {
      const countWrap = document.getElementById('history-count');
      const countValue = document.getElementById('history-count-value');
      if (!countWrap || !countValue) return;
      countValue.textContent = total.toString();
      countWrap.classList.remove('hidden');
    }

    function renderHistoryList(incidents, date, { total = 0 } = {}) {
      const listEl = document.getElementById('history-list');
      const dateLabel = date
        ? new Date(`${date}T00:00:00`).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' })
        : 'selected date';

      if (total === 0) {
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="icon">üìã</div>
            <p>No incidents available for</p>
            <p style="font-size: 12px; margin-top: 6px; color: var(--text); font-weight: 600;">${dateLabel}</p>
            <p style="font-size: 11px; margin-top: 10px;">Try another date (or the cache may not include that day yet).</p>
          </div>
        `;
        return;
      }

      if (incidents.length === 0) {
        const filterLabelStr = currentFilter === 'all' ? 'incidents' : `${filterLabel(currentFilter)} incidents`;
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="icon">üìã</div>
            <p>No ${filterLabelStr} for</p>
            <p style="font-size: 12px; margin-top: 6px; color: var(--text); font-weight: 600;">${dateLabel}</p>
            <p style="font-size: 11px; margin-top: 10px;">Try another filter or date.</p>
          </div>
        `;
        return;
      }

      listEl.innerHTML = incidents.map(inc => createIncidentCard(inc, false)).join('');
    }

    // Inline History date picker (no browser-native date input)
    const historyDateBtn = document.getElementById('history-date-btn');
    const historyDateValue = document.getElementById('history-date-value');
    const datePickerEl = document.getElementById('date-picker');

    const isoToday = new Date().toISOString().split('T')[0];
    let historySelectedDate = isoToday;
    let historyViewMonth = (() => {
      const d = parseISODate(isoToday);
      d.setDate(1);
      return d;
    })();

    function pad2(n) {
      return String(n).padStart(2, '0');
    }

    function isoFromParts(year, monthIndex, day) {
      return `${year}-${pad2(monthIndex + 1)}-${pad2(day)}`;
    }

    function parseISODate(iso) {
      const [y, m, d] = iso.split('-').map(Number);
      return new Date(y, (m || 1) - 1, d || 1);
    }

    function setHistoryDate(iso, { load = true } = {}) {
      historySelectedDate = iso;
      historyDateValue.textContent = iso;
      const d = parseISODate(iso);
      d.setDate(1);
      historyViewMonth = d;
      if (load) loadHistory(iso);
      renderDatePicker();
    }

    function toggleDatePicker(forceOpen) {
      const next = typeof forceOpen === 'boolean' ? forceOpen : !datePickerEl.classList.contains('open');
      datePickerEl.classList.toggle('open', next);
      datePickerEl.setAttribute('aria-hidden', String(!next));
      historyDateBtn.setAttribute('aria-expanded', String(next));
      if (next) renderDatePicker();
    }

    function renderDatePicker() {
      if (!datePickerEl.classList.contains('open')) return;

      const year = historyViewMonth.getFullYear();
      const month = historyViewMonth.getMonth();
      const firstDow = new Date(year, month, 1).getDay(); // 0=Sun
      const daysInMonth = new Date(year, month + 1, 0).getDate();

      const monthLabel = historyViewMonth.toLocaleString('en-US', { month: 'long', year: 'numeric' });
      const dows = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

      let html = `
        <div class="dp-header">
          <button type="button" class="dp-nav" data-action="prev" aria-label="Previous month">‚Äπ</button>
          <div class="dp-month">${monthLabel}</div>
          <button type="button" class="dp-nav" data-action="next" aria-label="Next month">‚Ä∫</button>
        </div>
        <div class="dp-grid">
          ${dows.map(d => `<div class="dp-dow">${d}</div>`).join('')}
      `;

      // Leading empties
      for (let i = 0; i < firstDow; i++) {
        html += `<button type="button" class="dp-day empty" tabindex="-1" disabled></button>`;
      }

      for (let day = 1; day <= daysInMonth; day++) {
        const iso = isoFromParts(year, month, day);
        const isSelected = iso === historySelectedDate;
        const isToday = iso === isoToday;
        const cls = [
          'dp-day',
          isSelected ? 'selected' : '',
          isToday ? 'today' : ''
        ].filter(Boolean).join(' ');
        html += `<button type="button" class="${cls}" data-date="${iso}">${day}</button>`;
      }

      // Trailing empties to fill last row (up to 42 day cells + 7 dows)
      const totalCells = firstDow + daysInMonth;
      const trailing = (7 - (totalCells % 7)) % 7;
      for (let i = 0; i < trailing; i++) {
        html += `<button type="button" class="dp-day empty" tabindex="-1" disabled></button>`;
      }

      html += `</div>`;
      datePickerEl.innerHTML = html;
    }

    historyDateBtn.addEventListener('click', () => toggleDatePicker());

    datePickerEl.addEventListener('click', (e) => {
      const action = e.target.closest('button[data-action]')?.dataset.action;
      if (action === 'prev') {
        historyViewMonth = new Date(historyViewMonth.getFullYear(), historyViewMonth.getMonth() - 1, 1);
        renderDatePicker();
        return;
      }
      if (action === 'next') {
        historyViewMonth = new Date(historyViewMonth.getFullYear(), historyViewMonth.getMonth() + 1, 1);
        renderDatePicker();
        return;
      }

      const date = e.target.closest('button[data-date]')?.dataset.date;
      if (date) {
        setHistoryDate(date, { load: true });
        toggleDatePicker(false);
      }
    });

    // Close date picker when clicking outside of it
    document.addEventListener('click', (e) => {
      if (!datePickerEl.classList.contains('open')) return;
      if (datePickerEl.contains(e.target) || historyDateBtn.contains(e.target)) return;
      toggleDatePicker(false);
    });
    
    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        const tabName = tab.dataset.tab;
        document.getElementById('live-panel').classList.toggle('hidden', tabName !== 'live');
        document.getElementById('history-panel').classList.toggle('hidden', tabName !== 'history');
        
        if (tabName === 'history') {
          mapMode = 'history';
          // Clear live markers immediately; history will repopulate after fetch
          setMapMarkers([], { mode: 'history' });
          // Make sure the date UI is initialized and load that date's cache
          setHistoryDate(historySelectedDate, { load: true });
          toggleDatePicker(false);
        } else {
          mapMode = 'live';
          const countWrap = document.getElementById('history-count');
          if (countWrap) countWrap.classList.add('hidden');
          // Live tab: make filter visibility reflect the active feed immediately
          updateFilterButtonVisibility(currentIncidents);
          // Render live markers immediately from the last-known active incidents
          setMapMarkers(getFilteredIncidents(currentIncidents, currentFilter), { fit: false, mode: 'live' });
          toggleDatePicker(false);
        }
      });
    });
    
    // Filter button handlers
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        applyFilter(btn.dataset.filter);
      });
    });
    
    // Initialize History date UI (default to today)
    setHistoryDate(isoToday, { load: false });
    
    // Initial load
    updateIncidents();
    updateStats();
    updateStatus();
    
    // Poll for updates every 15 seconds (backend scrapes every 60s)
    setInterval(() => {
      updateIncidents();
      updateStats();
      updateStatus();
    }, 15000);
  </script>
</body>
</html>
