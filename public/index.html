<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CADDO 911 LIVE</title>
  <link rel="icon" href="images/caddo911logo.png" type="image/png">
  <link rel="icon" href="images/caddo911logo.webp" type="image/webp">
  <link rel="apple-touch-icon" href="images/caddo911logo.png">
  <link rel="manifest" href="manifest.webmanifest?v=3.2.91LAbeta">
  <meta name="theme-color" content="#0a0a0f">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta property="og:title" content="Caddo 911 Live Feed">
  <meta property="og:description" content="Live emergency incident map for Caddo Parish, Louisiana.">
  <meta property="og:image" content="images/caddo911logo.png">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:image" content="images/caddo911logo.png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css?v=3.2.91LAbeta" />
</head>
<body>
  <header class="header">
    <div class="logo">
      <picture class="logo-icon">
        <source srcset="images/caddo911logo.webp" type="image/webp">
        <img src="images/caddo911logo.png" alt="Caddo 911" class="logo-icon-img">
      </picture>
      <div class="logo-text">
        <h1>CADDO PARISH</h1>
        <p>Emergency Dispatch Live Feed</p>
      </div>
    </div>
    <div class="status-bar">
      <div class="status-item status-live">
        <span class="status-label">Status</span>
        <span class="status-value live"><span class="live-dot"></span>LIVE</span>
      </div>
      <div class="status-item status-update">
        <span class="status-label">Last Update</span>
        <span class="status-value" id="last-update">--:--</span>
      </div>
      <div class="status-item status-active">
        <span class="status-label">Active</span>
        <span class="status-value" id="active-count">0</span>
      </div>
      <div class="status-item status-theme">
        <span class="status-label">Map Theme</span>
        <button class="map-theme-toggle" id="map-theme-toggle" aria-pressed="true" title="Toggle map theme">
          <span class="map-theme-icon" aria-hidden="true">‚òÄÔ∏è</span>
        </button>
      </div>
      <div class="status-item status-location">
        <span class="status-label">My Location</span>
        <button class="location-btn" id="location-btn" title="Show my location" aria-label="Show my location on the map">
          <span class="map-location-icon" aria-hidden="true">‚óé</span>
        </button>
      </div>
      <button class="settings-btn" id="settings-btn" onclick="toggleSettingsPanel()" title="Settings">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.49.49 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 0 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
        </button>
      <button class="info-btn" onclick="toggleInfoPanel()" title="About">i</button>
    </div>
  </header>
  
  <div class="settings-modal" id="settings-modal" aria-hidden="true">
    <div class="modal-backdrop" role="presentation"></div>
    <div class="modal-dialog settings-dialog" role="dialog" aria-modal="true" aria-label="Settings">
      <button class="modal-close" type="button" aria-label="Close" id="settings-close">√ó</button>
      <div class="settings-content">
        <h3>Settings</h3>
        <div class="setting-item">
          <label class="setting-label" for="setting-show-all-history">
            <span class="setting-title">Show all incidents on History map</span>
            <span class="setting-desc">When viewing History, display all incidents for the selected day on the map (not just the current page). Clicking a marker will navigate to its page.</span>
          </label>
          <label class="toggle-switch">
            <input type="checkbox" id="setting-show-all-history" checked>
            <span class="toggle-slider"></span>
          </label>
        </div>
      </div>
    </div>
  </div>
  
  <div class="info-modal" id="info-modal" aria-hidden="true">
    <div class="modal-backdrop" role="presentation"></div>
    <div class="modal-dialog" role="dialog" aria-modal="true" aria-label="About Caddo 911 Live">
      <button class="modal-close" type="button" aria-label="Close" id="info-close">√ó</button>
      <div class="info-content">
        <div class="info-hero">
          <img src="https://www.vincentlarkin.com/images/site-emblem.png" alt="Vincent Larkin emblem" class="info-logo">
          <div>
            <h3>Caddo 911 Live Feed</h3>
            <p style="margin-bottom: 6px;">Real-time emergency incident tracker for Caddo Parish, Louisiana.</p>
            <p style="margin-bottom: 0;">Built and maintained by Vincent Larkin.</p>
          </div>
        </div>
        
        <div class="notion-callout" role="note" aria-label="Disclaimer">
          <div class="icon" aria-hidden="true">i</div>
          <p>
            This website is a citizen-run project and is not affiliated with or endorsed by the State of Louisiana, any Louisiana state agency, Caddo Parish, or any Caddo Parish department or technology system. No state or parish funds were used to create or operate this project. <strong>$0.00</strong> of public funding has been spent on this website.
          </p>
        </div>
        
        <div class="info-links">
          <details class="info-dropdown">
            <summary>Parish Feed Links</summary>
            <div class="info-dropdown-links">
              <a href="https://ias.ecc.caddo911.com/All_ActiveEvents.aspx" target="_blank" class="info-link" rel="noopener noreferrer">
                <img src="images/caddo911.png" alt="Caddo 911 Emergency Communications Center" class="info-link-icon">
                Caddo Parish Feed
              </a>
              <a href="https://city.brla.gov/traffic/incidents.asp" target="_blank" class="info-link" rel="noopener noreferrer">
                <img src="https://city.brla.gov/favicon.ico" alt="City of Baton Rouge favicon" class="info-link-icon">
                Baton Rouge Traffic Feed
              </a>
              <a href="https://lafayette911.org/traffic/" target="_blank" class="info-link" rel="noopener noreferrer">
                <img src="images/lafayette-police.png" alt="Lafayette Parish Communication District traffic feed" class="info-link-icon">
                Lafayette Parish Feed (Beta)
              </a>
            </div>
          </details>
          <a href="https://github.com/vincentlarkin/Caddo911-Monitor" target="_blank" class="info-link">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
            GitHub
          </a>
          <a href="https://vincentlarkin.com" target="_blank" class="info-link">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
            Website
          </a>
          <a href="https://linkedin.com/in/vincentwlarkin" target="_blank" class="info-link">
            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
            LinkedIn
          </a>
        </div>
        <p class="info-credit">Made by <a class="info-credit-link" href="mailto:vincent@vincentlarkin.com">Vincent Larkin</a></p>
        <p class="info-version">v3.2.91LAbeta</p>
      </div>
    </div>
  </div>
  
  <main class="main-container">
    <div class="map-container">
      <div id="map"></div>
      <div class="legend-container" id="legend-container">
        <div class="map-overlay" id="map-legend">
          <button class="legend-collapse" id="legend-collapse" type="button" aria-expanded="true" aria-label="Collapse legend" title="Collapse legend">‚óÄ</button>
          
          <!-- Collapsed "handle" view (drawer-closed) -->
          <div class="legend-mini" aria-hidden="true">
            <div class="dot-stack">
              <span class="dot" style="background: var(--red);"></span>
              <span class="dot" style="background: var(--amber);"></span>
              <span class="dot" style="background: var(--blue);"></span>
              <span class="dot" style="background: var(--green);"></span>
              <span class="dot" style="background: var(--gray);"></span>
            </div>
          </div>
          
          <!-- Expanded content -->
          <div class="legend-content">
            <h3>Legend</h3>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--red)"></div>
              <span>High severity</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--amber)"></div>
              <span>Medium severity</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--blue)"></div>
              <span>Low severity</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--green)"></div>
              <span>Public service</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot" style="background: var(--gray)"></div>
              <span>Custody / prisoner</span>
            </div>
            <div style="margin-top: 10px; font-size: 10px; color: var(--text-dim); line-height: 1.4;">
              Colors = severity. Use the sidebar filters to limit by agency.
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <aside class="sidebar">
      <div class="tabs">
        <button class="tab active" data-tab="live">Live</button>
        <button class="tab" data-tab="history">History</button>
        <button class="panel-toggle" id="panel-toggle" type="button" aria-expanded="true" aria-label="Toggle incidents panel" title="Collapse incidents">‚ñº</button>
      </div>

      <div class="source-tabs" id="source-tabs" aria-label="Incident source">
        <button class="source-tab active" data-source="all" title="Show all sources">All</button>
        <button class="source-tab" data-source="caddo" title="Show only Caddo incidents">Caddo</button>
        <button class="source-tab" data-source="batonrouge" title="Show only Baton Rouge incidents">Baton Rouge</button>
        <button class="source-tab" data-source="lafayette" title="Show only Lafayette incidents">
          Lafayette <span class="beta-pill">Beta</span>
        </button>
      </div>

      <!-- Shared filters (apply to Live + History lists) -->
      <div class="filter-bar">
        <div class="filter-rows">
          <div class="agency-bank-controls hidden" id="agency-bank-controls">
            <button type="button" class="agency-bank-btn active" data-agency-view="caddo">Caddo Units</button>
            <button type="button" class="agency-bank-btn" data-agency-view="batonrouge">Baton Rouge Units</button>
            <button type="button" class="agency-bank-btn" data-agency-view="lafayette">Lafayette Units</button>
          </div>

          <!-- Caddo unit filters -->
          <div class="filter-group agency-group agency-group-caddo" data-filter-type="agency-caddo">
            <button class="filter-btn active" data-filter="all" title="All Caddo units">All</button>
            <button class="filter-btn" data-filter="cadfd" title="Caddo Fire/EMS">
              <img src="images/cfd-fire.png" alt="CAD-FD/EMS" class="filter-logo">
            </button>
            <button class="filter-btn" data-filter="shvfd" title="Shreveport Fire">
              <img src="images/sfd-fire.png" alt="SHVFD" class="filter-logo">
            </button>
            <button class="filter-btn" data-filter="police" title="Shreveport Police">
              <img src="images/spd-police.png" alt="Shreveport Police" class="filter-logo">
            </button>
            <button class="filter-btn" data-filter="sheriff" title="Caddo Sheriff">
              <img src="images/cso-sheriff.png" alt="Caddo Sheriff" class="filter-logo">
            </button>
          </div>

          <!-- Baton Rouge agency filters -->
          <div class="filter-group agency-group agency-group-batonrouge hidden" data-filter-type="agency-batonrouge">
            <button class="filter-btn active" data-br-agency="all" title="All Baton Rouge agencies">All</button>
            <button class="filter-btn" data-br-agency="law" title="Law enforcement incidents">LAW</button>
            <button class="filter-btn" data-br-agency="oss" title="OSS incidents">OSS</button>
          </div>

          <!-- Lafayette unit filters -->
          <div class="filter-group agency-group agency-group-lafayette hidden" data-filter-type="agency-lafayette">
            <button class="filter-btn active" data-laf-unit="all" title="All Lafayette units">All</button>
            <button class="filter-btn" data-laf-unit="police" title="Lafayette Police">
              <img src="images/lafayette-police.png" alt="Lafayette Police" class="filter-logo">
            </button>
            <button class="filter-btn" data-laf-unit="sheriff" title="Lafayette Sheriff">
              <img src="images/lafayette-sheriff.png" alt="Lafayette Sheriff" class="filter-logo">
            </button>
            <button class="filter-btn" data-laf-unit="fire" title="Lafayette Fire">
              <img src="images/lafayette-fire.png" alt="Lafayette Fire" class="filter-logo">
            </button>
          </div>
          <!-- Urgency/Severity filters -->
          <div class="filter-group" data-filter-type="urgency">
            <button class="filter-btn urgency-btn active" data-urgency="all" title="All severity levels">All</button>
            <button class="filter-btn urgency-btn urgency-high" data-urgency="high" title="High severity">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-medical" data-urgency="medical" title="Medical/EMS">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-medium" data-urgency="medium" title="Medium severity">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-low" data-urgency="low" title="Low severity">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-service" data-urgency="service" title="Public service">
              <span class="urgency-dot"></span>
            </button>
            <button class="filter-btn urgency-btn urgency-custody" data-urgency="custody" title="Custody/Prisoner">
              <span class="urgency-dot"></span>
            </button>
          </div>
        </div>
        <div class="filter-meta">
          <div class="history-count hidden" id="history-count">
            <span class="history-count-label" id="history-count-label">Incidents</span>
            <strong id="history-count-value">0</strong>
          </div>
          <div class="sort-control" id="sort-control">
            <button type="button" class="sort-btn" id="sort-toggle" aria-expanded="false" aria-controls="sort-menu" title="Sort incidents">
              <span>Sort</span>
              <svg class="sort-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <path d="M3 5h18v2H3V5zm4 6h10v2H7v-2zm4 6h2v2h-2v-2z"/>
              </svg>
            </button>
            <div class="sort-menu" id="sort-menu" aria-hidden="true">
              <button type="button" class="sort-option active" data-sort="recent">Most recent</button>
              <button type="button" class="sort-option" data-sort="urgency">Urgency</button>
            </div>
          </div>
        </div>
      </div>
      
      <div id="live-panel">
        <div class="incident-list" id="incident-list"></div>
      </div>
      
      <div id="history-panel" class="hidden">
        <div class="history-controls">
          <button type="button" id="history-date-btn" class="date-input" aria-expanded="false" aria-controls="date-picker">
            <div class="date-input-left">
              <div class="date-input-label">History date</div>
              <div class="date-input-value" id="history-date-value">----</div>
            </div>
            <svg class="date-input-icon" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M7 11h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2zM7 15h2v2H7v-2zm4 0h2v2h-2v-2zm4 0h2v2h-2v-2z"/>
              <path d="M19 4h-1V2h-2v2H8V2H6v2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"/>
            </svg>
          </button>
          <div class="date-picker" id="date-picker" aria-hidden="true"></div>
          <div class="history-pagination hidden" id="history-pagination" aria-label="History pages">
            <button type="button" class="page-btn" id="history-prev" aria-label="Previous page">‚Äπ</button>
            <div class="page-status" id="history-page-status">Page 1 of 1</div>
            <button type="button" class="page-btn" id="history-next" aria-label="Next page">‚Ä∫</button>
          </div>
        </div>
        <div class="incident-list" id="history-list"></div>
      </div>
    </aside>
  </main>
  
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Initialize map centered on Shreveport/Caddo Parish
    const map = L.map('map', {
      zoomControl: false,
      minZoom: 7,
      maxZoom: 19,
      worldCopyJump: true,
      preferCanvas: true,
      fadeAnimation: false,
      zoomAnimation: false,
      markerZoomAnimation: false
    }).setView([32.5252, -93.7502], 11);
    const markerRenderer = L.canvas({ padding: 0.5 });
    
    // Keep view constrained to a few-state window around Louisiana/Texas/Arkansas
    const southWest = L.latLng(29.0, -98.0);
    const northEast = L.latLng(34.5, -90.0);
    map.setMaxBounds(L.latLngBounds(southWest, northEast));
    
    // Dark basemap (keeps the UI in dark mode) with a separate label overlay for readability.
    // Base (no labels) in its own pane so we can color-grade it without affecting labels.
    map.createPane('base');
    map.getPane('base').classList.add('leaflet-base-pane');
    map.getPane('base').style.zIndex = 200;

    map.createPane('labels');
    map.getPane('labels').classList.add('leaflet-labels-pane');
    map.getPane('labels').style.zIndex = 650;
    map.getPane('labels').style.pointerEvents = 'none';

    map.createPane('parish');
    map.getPane('parish').classList.add('leaflet-parish-pane');
    map.getPane('parish').style.zIndex = 500;
    map.getPane('parish').style.pointerEvents = 'none';

    // Tile layers for light + dark themes
    const lightBase = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
      pane: 'base',
      attribution: '&copy; OpenStreetMap &copy; CARTO',
      subdomains: 'abcd',
      maxZoom: 19,
      crossOrigin: true
    });
    const lightLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
      pane: 'labels',
      subdomains: 'abcd',
      maxZoom: 19,
      opacity: 0.65,
      crossOrigin: true
    });
    const osmFallbackTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      pane: 'base',
      attribution: '&copy; OpenStreetMap contributors',
      maxZoom: 19,
      subdomains: 'abc',
      crossOrigin: true
    });
    const tileLayers = {
      dark: {
        base: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
          pane: 'base',
          attribution: '&copy; OpenStreetMap &copy; CARTO',
          subdomains: 'abcd',
          maxZoom: 19
        }),
        labels: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}{r}.png', {
          pane: 'labels',
          subdomains: 'abcd',
          maxZoom: 19,
          opacity: 1
        })
      },
      light: {
        base: lightBase,
        labels: lightLabels
      }
    };
    
    let mapTheme = 'light';
    let parishOutlineLayer = null;
    
    function setMapTheme(theme) {
      mapTheme = theme === 'dark' ? 'dark' : 'light';
      // Remove any existing layers
      Object.values(tileLayers.dark).forEach(layer => { if (map.hasLayer(layer)) map.removeLayer(layer); });
      Object.values(tileLayers.light).forEach(layer => { if (map.hasLayer(layer)) map.removeLayer(layer); });
      
      const layersToAdd = tileLayers[mapTheme];
      Object.values(layersToAdd).forEach(layer => layer.addTo(map));
      
      // If light tiles fail, fall back to standard OSM automatically
      if (mapTheme === 'light' && layersToAdd.base === lightBase) {
        const onError = () => {
          if (map.hasLayer(lightBase)) {
            map.removeLayer(lightBase);
            osmFallbackTiles.addTo(map);
            tileLayers.light.base = osmFallbackTiles;
            // drop labels to avoid mismatch
            if (map.hasLayer(lightLabels)) map.removeLayer(lightLabels);
            delete tileLayers.light.labels;
          }
        };
        lightBase.once('tileerror', onError);
      }
      
      document.body.classList.toggle('map-light', mapTheme === 'light');
      document.body.classList.toggle('map-dark', mapTheme === 'dark');
      
      const toggle = document.getElementById('map-theme-toggle');
      if (toggle) {
        const iconEl = toggle.querySelector('.map-theme-icon');
        if (iconEl) iconEl.textContent = mapTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
        toggle.setAttribute('aria-pressed', String(mapTheme === 'light'));
      }

      if (parishOutlineLayer) {
        parishOutlineLayer.setStyle(getParishOutlineStyle());
      }
    }
    
    // Default to dark mode
    setMapTheme('dark');

    function getParishOutlineStyle() {
      return {
        pane: 'parish',
        color: mapTheme === 'dark' ? 'rgba(232, 232, 240, 0.45)' : 'rgba(10, 10, 15, 0.6)',
        weight: 2,
        opacity: 0.95,
        fill: false
      };
    }

    async function loadParishOutline() {
      if (parishOutlineLayer) return;
      try {
        const response = await fetch('https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json');
        if (!response.ok) throw new Error(`Failed to load parish outline: ${response.status}`);
        const geojson = await response.json();
        const targetParishIds = new Set(['22017', '22033', '22055']); // Caddo, East Baton Rouge, Lafayette
        const features = (geojson?.features || []).filter(f => targetParishIds.has(String(f?.id)));
        if (!features.length) return;
        parishOutlineLayer = L.geoJSON(
          { type: 'FeatureCollection', features },
          { style: getParishOutlineStyle() }
        );
        parishOutlineLayer.addTo(map);
      } catch (error) {
        console.error(error);
      }
    }
    
    // Legend drawer (auto-collapse on narrow screens)
    const legendContainer = document.getElementById('legend-container');
    const legendPanel = document.getElementById('map-legend');
    const legendCollapse = document.getElementById('legend-collapse');

    function updateHeaderHeight() {
      const header = document.querySelector('.header');
      if (!header) return;
      document.documentElement.style.setProperty('--header-height', `${header.offsetHeight}px`);
    }
    
    function setLegendCollapsed(collapsed) {
      if (!legendContainer) return;
      legendContainer.classList.toggle('collapsed', collapsed);
      if (legendPanel) legendPanel.style.height = '';
      
      if (legendCollapse) {
        legendCollapse.setAttribute('aria-expanded', String(!collapsed));
        legendCollapse.textContent = collapsed ? '‚ñ∂' : '‚óÄ';
        legendCollapse.title = collapsed ? 'Expand legend' : 'Collapse legend';
        legendCollapse.setAttribute('aria-label', collapsed ? 'Expand legend' : 'Collapse legend');
      }
    }
    
    // Initial setup, then optionally collapse for smaller screens
    if (legendPanel) legendPanel.style.height = '';
    updateHeaderHeight();
    if (window.innerWidth < 960) setLegendCollapsed(true);
    
    legendCollapse?.addEventListener('click', () => {
      const isCollapsed = legendContainer?.classList.contains('collapsed');
      setLegendCollapsed(!isCollapsed);
    });
    
    // Keep layout-derived vars accurate on resize
    window.addEventListener('resize', () => {
      updateHeaderHeight();
    });
    window.addEventListener('load', updateHeaderHeight);
    
    // Add zoom control to bottom right
    L.control.zoom({ position: 'bottomright' }).addTo(map);
    
    const mapThemeToggle = document.getElementById('map-theme-toggle');
    if (mapThemeToggle) {
      mapThemeToggle.addEventListener('click', () => {
        setMapTheme(mapTheme === 'light' ? 'dark' : 'light');
      });
    }

    const locationBtn = document.getElementById('location-btn');
    let userLocationMarker = null;
    let userLocationAccuracyCircle = null;
    let geolocationWatchId = null;
    let latestUserLatLng = null;
    let hasCenteredOnUser = false;
    let followUserLocation = false;
    let hasPrimedHighAccuracy = false;
    const TARGET_ACCURACY_METERS = 100;
    const MAX_WAIT_FOR_BETTER_FIX_MS = 12000;
    let locationTrackingStartedAt = 0;
    let bestAccuracyMeters = Number.POSITIVE_INFINITY;
    let bestLocationLatLng = null;
    let waitingForBetterFixLogged = false;

    function metersToMiles(meters) {
      return Number(meters) / 1609.344;
    }

    function logLocationEvent(message, extra = null) {
      if (extra == null) {
        console.info(`[location] ${message}`);
        return;
      }
      console.info(`[location] ${message}`, extra);
    }

    function setLocationButtonState(state = 'idle', title = 'Show my location') {
      if (!locationBtn) return;
      const icon = locationBtn.querySelector('.map-location-icon');
      locationBtn.classList.remove('locating', 'active', 'error');
      locationBtn.title = title;
      locationBtn.setAttribute('aria-label', title);

      if (state === 'locating') {
        locationBtn.classList.add('locating');
        if (icon) icon.textContent = '‚Ä¶';
      } else if (state === 'active') {
        locationBtn.classList.add('active');
        if (icon) icon.textContent = '‚óé';
      } else if (state === 'error') {
        locationBtn.classList.add('error');
        if (icon) icon.textContent = '!';
      } else if (icon) {
        icon.textContent = '‚óé';
      }
    }

    function updateUserLocation(position) {
      const lat = Number(position?.coords?.latitude);
      const lng = Number(position?.coords?.longitude);
      const accuracy = Number(position?.coords?.accuracy || 0);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;

      if (Number.isFinite(accuracy) && accuracy > 0 && accuracy < bestAccuracyMeters) {
        bestAccuracyMeters = accuracy;
        bestLocationLatLng = [lat, lng];
        logLocationEvent('improved location accuracy', {
          lat: Number(lat.toFixed(6)),
          lng: Number(lng.toFixed(6)),
          accuracyMiles: Number(metersToMiles(accuracy).toFixed(3))
        });
      }

      const hasBetterFix = Array.isArray(bestLocationLatLng) && Number.isFinite(bestAccuracyMeters);
      const useBestFix = hasBetterFix && bestAccuracyMeters + 10 < accuracy;
      const displayLatLng = useBestFix ? bestLocationLatLng : [lat, lng];
      const displayAccuracy = useBestFix ? bestAccuracyMeters : accuracy;

      logLocationEvent('got location update', {
        lat: Number(lat.toFixed(6)),
        lng: Number(lng.toFixed(6)),
        accuracyMiles: Number(metersToMiles(accuracy).toFixed(3)),
        timestamp: new Date(position.timestamp || Date.now()).toISOString()
      });

      latestUserLatLng = displayLatLng;
      const radius = Math.max(displayAccuracy, 15);

      if (!userLocationMarker) {
        userLocationMarker = L.circleMarker(latestUserLatLng, {
          radius: 7,
          color: '#ffffff',
          weight: 2,
          fillColor: '#3b8bff',
          fillOpacity: 0.95,
          pane: 'markerPane'
        }).bindPopup('You are here');
        userLocationMarker.addTo(map);
      } else {
        userLocationMarker.setLatLng(latestUserLatLng);
      }

      if (!userLocationAccuracyCircle) {
        userLocationAccuracyCircle = L.circle(latestUserLatLng, {
          radius,
          color: '#3b8bff',
          weight: 1,
          fillColor: '#3b8bff',
          fillOpacity: 0.12,
          interactive: false,
          pane: 'overlayPane'
        }).addTo(map);
      } else {
        userLocationAccuracyCircle.setLatLng(latestUserLatLng);
        userLocationAccuracyCircle.setRadius(radius);
      }

      const elapsedMs = Math.max(0, Date.now() - locationTrackingStartedAt);
      const accuracyGoodEnough = displayAccuracy <= TARGET_ACCURACY_METERS;
      const waitedLongEnough = elapsedMs >= MAX_WAIT_FOR_BETTER_FIX_MS;

      if (!hasCenteredOnUser && !accuracyGoodEnough && !waitedLongEnough && !waitingForBetterFixLogged) {
        waitingForBetterFixLogged = true;
        logLocationEvent('waiting for better GPS fix', {
          currentAccuracyMiles: Number(metersToMiles(displayAccuracy).toFixed(3)),
          targetAccuracyMiles: Number(metersToMiles(TARGET_ACCURACY_METERS).toFixed(3))
        });
      }

      if (!hasCenteredOnUser && (accuracyGoodEnough || waitedLongEnough)) {
        waitingForBetterFixLogged = false;
      }

      if (!hasCenteredOnUser && (accuracyGoodEnough || waitedLongEnough)) {
        map.flyTo(latestUserLatLng, Math.max(map.getZoom(), 16), { duration: 0.5 });
        hasCenteredOnUser = true;
      } else if (followUserLocation) {
        map.flyTo(latestUserLatLng, Math.max(map.getZoom(), 16), { duration: 0.5 });
      }

      const accuracyLabelMiles = Number(metersToMiles(displayAccuracy).toFixed(2));
      setLocationButtonState('active', `Center on my location (~${accuracyLabelMiles} mi)`);
    }

    function startLocationTracking() {
      if (!navigator.geolocation) {
        logLocationEvent('geolocation unavailable in this browser');
        setLocationButtonState('error', 'Geolocation not available in this browser');
        return;
      }
      if (geolocationWatchId != null) {
        logLocationEvent('tracking already active');
        return;
      }

      logLocationEvent('location button clicked, requesting high-accuracy position');
      setLocationButtonState('locating', 'Getting your location...');
      locationTrackingStartedAt = Date.now();
      bestAccuracyMeters = Number.POSITIVE_INFINITY;
      bestLocationLatLng = null;
      waitingForBetterFixLogged = false;

      // Prime with a one-shot lookup first (fresh reading, no cache)
      if (!hasPrimedHighAccuracy) {
        hasPrimedHighAccuracy = true;
        navigator.geolocation.getCurrentPosition(
          (position) => {
            updateUserLocation(position);
          },
          (error) => {
            logLocationEvent('initial location lookup failed', {
              code: error?.code,
              message: error?.message || 'Unknown geolocation error'
            });
          },
          {
            enableHighAccuracy: true,
            timeout: 20000,
            maximumAge: 0
          }
        );
      }

      geolocationWatchId = navigator.geolocation.watchPosition(
        (position) => updateUserLocation(position),
        (error) => {
          geolocationWatchId = null;
          followUserLocation = false;
          const denied = error?.code === 1;
          const title = denied ? 'Location permission denied' : 'Unable to get your location';
          logLocationEvent('watch position failed', {
            code: error?.code,
            message: error?.message || 'Unknown geolocation error'
          });
          setLocationButtonState('error', title);
        },
        {
          enableHighAccuracy: true,
          timeout: 20000,
          maximumAge: 0
        }
      );
    }

    locationBtn?.addEventListener('click', () => {
      followUserLocation = true;
      if (latestUserLatLng) {
        map.flyTo(latestUserLatLng, Math.max(map.getZoom(), 16), { duration: 0.5 });
        setLocationButtonState('active', 'Center on my location');
        return;
      }
      startLocationTracking();
    });

    map.on('dragstart zoomstart', () => {
      followUserLocation = false;
    });
    
    // Store markers
    const markers = new Map();
    let currentIncidents = [];
    let currentHistoryIncidents = [];
    let currentSource = 'all'; // 'all' | 'caddo' | 'batonrouge' | 'lafayette'
    let currentLafayetteUnit = 'all'; // 'all' | 'police' | 'sheriff' | 'fire'
    let currentBatonRougeAgency = 'all'; // 'all' | 'law' | 'oss'
    let agencyButtonView = 'caddo'; // which button bank is currently visible
    let currentFilter = 'all';  // Agency filter
    let currentUrgencyFilter = 'all';  // Urgency/severity filter
    let currentSort = 'recent'; // 'recent' | 'urgency'
    let mapMode = 'live'; // 'live' | 'history'
    let historyPage = 1;
    const historyPageSize = 35;
    let historyTotal = 0;
    let historyHasAllIncidents = false;
    let lastLiveListSignature = '';
    let lastHistoryListSignature = '';
    const caddoFilterButtons = Array.from(document.querySelectorAll('.filter-group[data-filter-type="agency-caddo"] .filter-btn'));
    const batonRougeFilterButtons = Array.from(document.querySelectorAll('.filter-group[data-filter-type="agency-batonrouge"] .filter-btn'));
    const lafayetteFilterButtons = Array.from(document.querySelectorAll('.filter-group[data-filter-type="agency-lafayette"] .filter-btn'));
    const urgencyFilterButtons = Array.from(document.querySelectorAll('.filter-group[data-filter-type="urgency"] .filter-btn'));

    function buildIncidentListSignature(incidents, keyPrefix = '') {
      const items = Array.isArray(incidents) ? incidents : [];
      const base = items.map((inc) => `${inc.id}:${inc.time || ''}:${inc.units || ''}:${inc.source || ''}`).join('|');
      return `${keyPrefix}|${base}`;
    }
    
    // Agency color mapping
    function getAgencyColor(agency) {
      if (agency.startsWith('CFD') || agency.startsWith('SFD') || agency.includes('FIRE')) return '#ff6b35'; // Fire
      if (agency === 'EMS' || agency.includes('EMS')) return '#ff3b6b'; // Medical
      if (agency === 'SPD' || agency.includes('POLICE')) return '#3b8bff'; // Police
      if (agency === 'CSO' || agency.includes('SHERIFF')) return '#9b59b6'; // Sheriff
      return '#ffb830'; // Other
    }
    
    function getAgencyClass(agency) {
      if (agency.startsWith('CFD') || agency.startsWith('SFD') || agency.includes('FIRE')) return 'fire';
      if (agency === 'EMS' || agency.includes('EMS')) return 'medical';
      if (agency === 'SPD' || agency.includes('POLICE')) return 'police';
      if (agency === 'CSO' || agency.includes('SHERIFF')) return 'sheriff';
      return 'other';
    }
    
    // Severity classification (meaningful colors)
    // - high: life safety / violence / fire / serious traffic
    // - medium: theft / hazards / accidents
    // - low: follow-up / reports / citizen assist
    function _normalizeDesc(description) {
      return String(description || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function _includesAny(text, terms) {
      for (const t of terms) {
        if (text.includes(t)) return true;
      }
      return false;
    }

    const SEVERITY_TERMS = {
      custody: ['prisoner'],
      medical: ['medical emergency', 'caddo ems event'],
      service: ['special event stand by', 'public service'],
      low: [
        'deliver message', 'prisoner medical security', 'periodic check', 'taken by other agency',
        'follow up', 'followup', 'follow', 'investigation', 'report', 'information',
        'citizen assist', 'citizen assistance', 'assist citizen', 'civil',
        'welfare check', 'wellness check', 'property check', 'extra patrol', 'directed patrol',
        'noise', 'complaint', 'parking', 'traffic control', 'traffic stop',
        'lost property', 'found property',
      ],
      high: [
        'shots fired', 'shooting', 'shot fired', 'gun', 'armed', 'weapon',
        'stabbing', 'stab', 'knife',
        'assault', 'battery', 'domestic', 'fight',
        'robbery', 'home invasion', 'kidnap', 'hostage',
        'homicide', 'murder', 'rape', 'sexual',
        'theft', 'burglary', 'vehicle burglary', 'break in', 'breaking entering',
        'structure fire', 'house fire', 'apartment fire', 'building fire',
        'fire', 'smoke', 'explosion',
        'medical', 'ems', 'unconscious', 'not breathing', 'difficulty breathing', 'choking',
        'overdose', 'cardiac', 'heart', 'stroke', 'seizure',
        'hit and run', 'hit run', 'injury accident', 'accident with injuries', 'fatal', 'entrap', 'rollover',
      ],
      medium: [
        'stolen', 'shoplift', 'vandal',
        'accident', 'crash', 'wreck', 'collision', 'mvc', 'mva',
        'road hazard', 'debris', 'disabled vehicle',
        'loose livestock', 'livestock', 'loose animal', 'animal in roadway', 'cow', 'horse',
        'disturbance', 'suspicious', 'trespass', 'harassment', 'fraud', 'alarm',
        'juvenile complaint',
      ],
    };

    function getSeverity(incident) {
      if (!incident || typeof incident !== 'object') return 'medium';
      if (incident._severity) return incident._severity;

      const d = _normalizeDesc(incident.description);
      const agency = String(incident.agency || '').toUpperCase();

      if (d.includes('minor accident') || d.includes('minor crash') || d.includes('fender bender')) {
        incident._severity = 'low';
        return incident._severity;
      }

      if (_includesAny(d, SEVERITY_TERMS.custody)) {
        incident._severity = 'custody';
      } else if (agency === 'EMS' || agency.includes('EMS')) {
        incident._severity = 'medical';
      } else if (_includesAny(d, SEVERITY_TERMS.medical)) {
        incident._severity = 'medical';
      } else if (_includesAny(d, SEVERITY_TERMS.service)) {
        incident._severity = 'service';
      } else if (_includesAny(d, SEVERITY_TERMS.high)) {
        incident._severity = 'high';
      } else if (_includesAny(d, SEVERITY_TERMS.low)) {
        incident._severity = 'low';
      } else if (_includesAny(d, SEVERITY_TERMS.medium)) {
        incident._severity = 'medium';
      } else {
        incident._severity = (agency === 'EMS' || agency.includes('EMS')) ? 'high' : 'medium';
      }

      return incident._severity;
    }

    function getSeverityClass(sev) {
      if (sev === 'medical') return 'sev-medical';
      if (sev === 'custody') return 'sev-custody';
      if (sev === 'service') return 'sev-service';
      return sev === 'high' ? 'sev-high' : sev === 'low' ? 'sev-low' : 'sev-medium';
    }

    function getSeverityColor(sev) {
      if (sev === 'high' || sev === 'medical') return '#ff3b3b';
      if (sev === 'custody') return '#9aa0aa';
      if (sev === 'service') return '#00ff88';
      if (sev === 'low') return '#3b8bff';
      return '#ffb830';
    }

    function getMarkerFill(sev) {
      return getSeverityColor(sev);
    }

    const SOURCE_ORDER = ['caddo', 'batonrouge', 'lafayette'];
    const SOURCE_MAP_VIEWS = {
      caddo: { center: [32.5252, -93.7502], zoom: 11 },
      batonrouge: { center: [30.4515, -91.1871], zoom: 11 },
      lafayette: { center: [30.2241, -92.0198], zoom: 11 },
      all: { center: [31.0, -92.3], zoom: 7 },
    };

    function normalizeSource(source) {
      const s = String(source || '').trim().toLowerCase();
      if (s === 'batonrouge') return 'batonrouge';
      if (s === 'lafayette') return 'lafayette';
      if (s === 'caddo') return 'caddo';
      return 'caddo';
    }

    function sourceLabel(source) {
      if (source === 'batonrouge') return 'Baton Rouge';
      return source === 'lafayette' ? 'Lafayette (Beta)' : 'Caddo';
    }

    function focusMapOnSourceSelection(source) {
      const key = String(source || 'all').toLowerCase();
      const view = SOURCE_MAP_VIEWS[key] || SOURCE_MAP_VIEWS.all;
      map.flyTo(view.center, view.zoom, { duration: 0.45 });
    }

    function sourceQueryParam() {
      return `source=${encodeURIComponent(currentSource)}`;
    }

    function getIncidentAgencyUnits(incident) {
      const source = normalizeSource(incident?.source);
      const raw = String(incident?.agency || '').toUpperCase();
      if (!raw) return [];
      if (source !== 'lafayette') return [raw];

      const matches = raw.match(/\b(FIRE|POLICE|SHERIFF)\b/g) || [];
      const ordered = [];
      for (const unit of matches) {
        if (!ordered.includes(unit)) ordered.push(unit);
      }
      return ordered.length ? ordered : [raw];
    }

    function formatAgencyDisplay(incident) {
      const source = normalizeSource(incident?.source);
      const units = getIncidentAgencyUnits(incident);
      if (source === 'lafayette') {
        return units.join(' / ') || 'UNKNOWN';
      }
      return String(incident?.agency || 'UNKNOWN');
    }

    function groupIncidentsBySource(incidents) {
      const grouped = new Map([
        ['caddo', []],
        ['batonrouge', []],
        ['lafayette', []],
      ]);
      (incidents || []).forEach((incident) => {
        const source = normalizeSource(incident?.source);
        if (!grouped.has(source)) grouped.set(source, []);
        incident.source = source;
        grouped.get(source).push(incident);
      });
      return grouped;
    }

    function renderSourceGroups(incidents) {
      const grouped = groupIncidentsBySource(incidents);
      let html = '';
      SOURCE_ORDER.forEach((source) => {
        const rows = grouped.get(source) || [];
        if (!rows.length) return;
        html += `
          <section class="source-group">
            <div class="source-group-header">${sourceLabel(source)} - ${rows.length}</div>
            ${rows.map(inc => createIncidentCard(inc, false)).join('')}
          </section>
        `;
      });
      return html;
    }
    
    // Filter logic - matches agency codes to filter categories
    function matchesAgencyFilter(incident, filter) {
      if (filter === 'all') return true;
      const source = normalizeSource(incident?.source);
      if (source !== 'caddo') return true; // Caddo filter should never filter Lafayette incidents.

      const agency = incident.agency.toUpperCase();
      
      switch (filter) {
        case 'cadfd':
          return agency.startsWith('CFD');
        case 'shvfd':
          return agency.startsWith('SFD');
        case 'police':
          return agency === 'SPD' || agency.includes('POLICE');
        case 'sheriff':
          return agency === 'CSO' || agency.includes('SHERIFF');
        default:
          return true;
      }
    }

    // Urgency filter logic - matches severity levels
    function matchesUrgencyFilter(incident, urgencyFilter) {
      if (urgencyFilter === 'all') return true;
      const sev = getSeverity(incident);
      return sev === urgencyFilter;
    }

    // Lafayette-only unit filter. This does not affect Caddo incidents.
    function matchesLafayetteUnitFilter(incident, unitFilter = currentLafayetteUnit) {
      const uf = unitFilter || 'all';
      if (uf === 'all') return true;

      const source = normalizeSource(incident?.source);
      if (source !== 'lafayette') return true;

      const units = getIncidentAgencyUnits(incident);
      if (uf === 'police') return units.includes('POLICE');
      if (uf === 'sheriff') return units.includes('SHERIFF');
      if (uf === 'fire') return units.includes('FIRE');
      return true;
    }

    function matchesBatonRougeAgencyFilter(incident, agencyFilter = currentBatonRougeAgency) {
      const af = String(agencyFilter || 'all').toLowerCase();
      if (af === 'all') return true;

      const source = normalizeSource(incident?.source);
      if (source !== 'batonrouge') return true;

      const agency = String(incident?.agency || '').toUpperCase();
      if (af === 'law') return agency.includes('LAW');
      if (af === 'oss') return agency.includes('OSS');
      return true;
    }

    function matchesActiveUnitFilters(incident) {
      const source = normalizeSource(incident?.source);
      if (source === 'lafayette') return matchesLafayetteUnitFilter(incident, currentLafayetteUnit);
      if (source === 'batonrouge') return matchesBatonRougeAgencyFilter(incident, currentBatonRougeAgency);
      return matchesAgencyFilter(incident, currentFilter);
    }

    function matchesSourceFilter(incident, source = currentSource) {
      const selectedSource = normalizeSource(source);
      if (source === 'all') return true;
      return normalizeSource(incident?.source) === selectedSource;
    }

    // Combined filter - checks agency + urgency + Lafayette unit.
    function matchesFilters(incident, agencyFilter, urgencyFilter) {
      return (
        matchesSourceFilter(incident) &&
        matchesAgencyFilter(incident, agencyFilter) &&
        matchesBatonRougeAgencyFilter(incident) &&
        matchesUrgencyFilter(incident, urgencyFilter) &&
        matchesLafayetteUnitFilter(incident)
      );
    }
    
    function filterLabel(filter) {
      switch (filter) {
        case 'cadfd': return 'CAD-FD/EMS';
        case 'shvfd': return 'SHVFD';
        case 'police': return 'police';
        case 'sheriff': return 'sheriff';
        default: return filter;
      }
    }

    function urgencyLabel(urgency) {
      switch (urgency) {
        case 'high': return 'high severity';
        case 'medical': return 'medical/EMS';
        case 'medium': return 'medium severity';
        case 'low': return 'low severity';
        case 'service': return 'public service';
        case 'custody': return 'custody';
        default: return urgency;
      }
    }

    function currentUnitFilterValueForUi() {
      if (currentSource === 'lafayette') return currentLafayetteUnit;
      if (currentSource === 'batonrouge') return currentBatonRougeAgency;
      if (currentSource === 'caddo') return currentFilter;
      // In "All", mirror whichever unit bank is currently visible.
      if (agencyButtonView === 'batonrouge') return currentBatonRougeAgency;
      return agencyButtonView === 'lafayette' ? currentLafayetteUnit : currentFilter;
    }

    function currentUnitFilterLabelForUi() {
      const value = currentUnitFilterValueForUi();
      if (agencyButtonView === 'batonrouge' || currentSource === 'batonrouge') {
        if (value === 'law') return 'baton rouge law';
        if (value === 'oss') return 'baton rouge oss';
        return 'baton rouge agencies';
      }
      if (agencyButtonView === 'lafayette' || currentSource === 'lafayette') {
        if (value === 'police') return 'lafayette police';
        if (value === 'sheriff') return 'lafayette sheriff';
        if (value === 'fire') return 'lafayette fire';
        return 'lafayette units';
      }
      return filterLabel(value);
    }

    function getFilteredIncidents(incidents, agencyFilter, urgencyFilter) {
      const af = agencyFilter ?? currentFilter;
      const uf = urgencyFilter ?? currentUrgencyFilter;
      return incidents.filter(inc => matchesFilters(inc, af, uf));
    }

    function getHistoryPageData(incidents) {
      const filtered = getFilteredIncidents(incidents, currentFilter, currentUrgencyFilter);
      if (!historyHasAllIncidents) {
        if (currentSort === 'urgency') {
          return { pageData: sortIncidents(filtered), skipSort: true };
        }
        return { pageData: filtered, skipSort: true };
      }
      const sortedAll = sortIncidents(filtered);
      const offset = (historyPage - 1) * historyPageSize;
      return { pageData: sortedAll.slice(offset, offset + historyPageSize), skipSort: true };
    }

    function _incidentTimeValue(incident) {
      const raw = incident?.time;
      if (raw != null && String(raw).trim() !== '') {
        const normalized = Number(String(raw).padStart(4, '0'));
        if (!Number.isNaN(normalized)) return normalized;
      }
      if (incident?.first_seen) {
        const parsed = Date.parse(incident.first_seen);
        return Number.isNaN(parsed) ? 0 : parsed;
      }
      return 0;
    }

    function _urgencyRank(incident) {
      const sev = getSeverity(incident);
      return sev === 'high' ? 5
        : sev === 'medical' ? 4
        : sev === 'medium' ? 3
        : sev === 'low' ? 2
        : sev === 'service' ? 1
        : 0;
    }

    function sortIncidents(incidents) {
      const list = Array.isArray(incidents) ? [...incidents] : [];
      if (currentSort === 'urgency') {
        return list.sort((a, b) => _urgencyRank(b) - _urgencyRank(a));
      }
      return list.sort((a, b) => _incidentTimeValue(b) - _incidentTimeValue(a));
    }

    // Update filter button visibility and counts for both agency and urgency filters.
    // This dims filters with 0 incidents so users understand they're empty.
    function updateFilterButtonVisibility(baseIncidents) {
      // Caddo unit counts (considering current urgency filter)
      const caddoCounts = {
        cadfd: 0,
        shvfd: 0,
        police: 0,
        sheriff: 0,
      };
      const batonRougeCounts = {
        law: 0,
        oss: 0,
      };
      const lafayetteCounts = {
        police: 0,
        sheriff: 0,
        fire: 0,
      };

      // Urgency counts (considering current unit filters per source)
      const urgencyCounts = {
        high: 0,
        medical: 0,
        medium: 0,
        low: 0,
        service: 0,
        custody: 0,
      };

      for (const inc of baseIncidents || []) {
        const source = normalizeSource(inc?.source);
        const sev = getSeverity(inc);
        
        // Count unit filters (apply current urgency filter only).
        if (matchesUrgencyFilter(inc, currentUrgencyFilter)) {
          if (source === 'caddo') {
            if (matchesAgencyFilter(inc, 'cadfd')) caddoCounts.cadfd += 1;
            if (matchesAgencyFilter(inc, 'shvfd')) caddoCounts.shvfd += 1;
            if (matchesAgencyFilter(inc, 'police')) caddoCounts.police += 1;
            if (matchesAgencyFilter(inc, 'sheriff')) caddoCounts.sheriff += 1;
          } else if (source === 'batonrouge') {
            if (matchesBatonRougeAgencyFilter(inc, 'law')) batonRougeCounts.law += 1;
            if (matchesBatonRougeAgencyFilter(inc, 'oss')) batonRougeCounts.oss += 1;
          } else if (source === 'lafayette') {
            if (matchesLafayetteUnitFilter(inc, 'police')) lafayetteCounts.police += 1;
            if (matchesLafayetteUnitFilter(inc, 'sheriff')) lafayetteCounts.sheriff += 1;
            if (matchesLafayetteUnitFilter(inc, 'fire')) lafayetteCounts.fire += 1;
          }
        }

        // Count urgency filters (apply current source-specific unit filters).
        if (matchesActiveUnitFilters(inc)) {
          if (urgencyCounts.hasOwnProperty(sev)) {
            urgencyCounts[sev] += 1;
          }
        }
      }

      // Always show filter "tabs" even when they have 0 incidents.
      // Visually dim them so users understand they‚Äôre empty, but still allow clicking
      // (the list will show a "No incidents" message).
      caddoFilterButtons.forEach(btn => {
        const f = btn.dataset.filter;
        if (f === 'all') {
          btn.dataset.count = '';
          btn.classList.remove('empty');
          return;
        }
        const count = caddoCounts[f] || 0;
        btn.dataset.count = String(count);
        btn.classList.toggle('empty', count === 0);
      });
      batonRougeFilterButtons.forEach(btn => {
        const agency = btn.dataset.brAgency;
        if (agency === 'all') {
          btn.dataset.count = '';
          btn.classList.remove('empty');
          return;
        }
        const count = batonRougeCounts[agency] || 0;
        btn.dataset.count = String(count);
        btn.classList.toggle('empty', count === 0);
      });
      lafayetteFilterButtons.forEach(btn => {
        const unit = btn.dataset.lafUnit;
        if (unit === 'all') {
          btn.dataset.count = '';
          btn.classList.remove('empty');
          return;
        }
        const count = lafayetteCounts[unit] || 0;
        btn.dataset.count = String(count);
        btn.classList.toggle('empty', count === 0);
      });

      // Update urgency filter buttons
      urgencyFilterButtons.forEach(btn => {
        const u = btn.dataset.urgency;
        if (u === 'all') {
          btn.dataset.count = '';
          btn.classList.remove('empty');
          return;
        }
        const count = urgencyCounts[u] || 0;
        btn.dataset.count = String(count);
        btn.classList.toggle('empty', count === 0);
      });

      // If the active agency filter has no incidents (after urgency filter), fall back to "all".
      if (currentFilter !== 'all' && (caddoCounts[currentFilter] || 0) === 0) {
        currentFilter = 'all';
      }
      if (currentBatonRougeAgency !== 'all' && (batonRougeCounts[currentBatonRougeAgency] || 0) === 0) {
        currentBatonRougeAgency = 'all';
      }
      if (currentLafayetteUnit !== 'all' && (lafayetteCounts[currentLafayetteUnit] || 0) === 0) {
        currentLafayetteUnit = 'all';
      }

      // If the active urgency filter has no incidents (after agency filter), fall back to "all".
      if (currentUrgencyFilter !== 'all' && (urgencyCounts[currentUrgencyFilter] || 0) === 0) {
        currentUrgencyFilter = 'all';
      }

      // Keep active state consistent (especially after fallback)
      caddoFilterButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === currentFilter);
      });
      batonRougeFilterButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.brAgency === currentBatonRougeAgency);
      });
      lafayetteFilterButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lafUnit === currentLafayetteUnit);
      });
      urgencyFilterButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.urgency === currentUrgencyFilter);
      });
    }
    
    function _stringHash(str) {
      // Stable 32-bit hash for deterministic marker shapes per incident
      let h = 2166136261;
      const s = String(str || '');
      for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    function _incidentSeed(incident) {
      return _stringHash(incident?.hash || incident?.id || '');
    }

    function _triangleLatLngs(lat, lng, sizeMeters, seed) {
      // Small equilateral-ish triangle around a center point, rotated deterministically.
      const base = [
        [0, 1],
        [-0.866, -0.5],
        [0.866, -0.5],
      ];
      const angle = ((seed % 360) * Math.PI) / 180;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);

      const latRad = (lat * Math.PI) / 180;
      const mPerDegLat = 111320;
      const mPerDegLng = 111320 * Math.cos(latRad);

      return base.map(([x, y]) => {
        const rx = x * cos - y * sin;
        const ry = x * sin + y * cos;
        const dLat = (ry * sizeMeters) / mPerDegLat;
        const dLng = (rx * sizeMeters) / (mPerDegLng || 1);
        return [lat + dLat, lng + dLng];
      });
    }

    function _geocodeTriangleSizeMeters(incident, mode) {
      const src = String(incident?.geocode_source || '').toLowerCase();
      const q = String(incident?.geocode_quality || '').toLowerCase();

      // Defaults: slightly generalized even for "good" geocodes (avoids false precision).
      let size = mode === 'history' ? 70 : 85;

      if (src === 'fallback' || q === 'fallback' || q === 'city-only') {
        size = mode === 'history' ? 220 : 260;
      } else if (q === 'cross-only') {
        size = mode === 'history' ? 160 : 190;
      } else if (q === 'street-only') {
        size = mode === 'history' ? 140 : 170;
      } else if (q === 'street+cross') {
        size = mode === 'history' ? 90 : 110;
      } else if (q === 'intersection-2') {
        size = mode === 'history' ? 65 : 80;
      }

      return size;
    }

    function googleMapsUrl(lat, lng) {
      const q = `${Number(lat).toFixed(6)},${Number(lng).toFixed(6)}`;
      return `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(q)}`;
    }

    // Create custom marker (triangle area instead of pinpoint dot)
    function createMarker(incident, { mode = 'live' } = {}) {
      const sev = getSeverity(incident);
      const color = getSeverityColor(sev);
      const fillColor = getMarkerFill(sev);
      const agencyDisplay = formatAgencyDisplay(incident);
      
      const locationParts = [];
      if (incident.street) locationParts.push(incident.street);
      if (incident.cross_streets) locationParts.push(incident.cross_streets);
      const locationStr = locationParts.join(' @ ') || 'Unknown';

      const seed = _incidentSeed(incident);
      const sizeMeters = _geocodeTriangleSizeMeters(incident, mode);
      const points = _triangleLatLngs(incident.latitude, incident.longitude, sizeMeters, seed);
      const gmaps = googleMapsUrl(incident.latitude, incident.longitude);
      
      // Build popup content - add "Go to page" link for history mode when showing all incidents
      let popupHtml = `
        <div class="popup-content">
          <div class="popup-title">${incident.description}</div>
          <div class="popup-detail">üìç ${locationStr}</div>
          <div class="popup-detail">üïê ${formatTime(incident.time)}</div>
          <div class="popup-detail">üö® ${agencyDisplay} ‚Ä¢ ${incident.units} unit(s)</div>
          <div class="popup-detail">‚ö†Ô∏è Severity: ${sev.toUpperCase()}</div>
          <a class="popup-link" href="${gmaps}" target="_blank" rel="noopener noreferrer">Open in Google Maps</a>
      `;
      
      // Add "Go to incident" button for history mode with show all enabled
      if (mode === 'history' && showAllHistoryOnMap) {
        popupHtml += `<button class="popup-goto-btn" onclick="navigateToIncidentPage(${incident.id})">Go to incident in list</button>`;
      }
      
      popupHtml += `</div>`;
      
      const marker = L.polygon(points, {
        renderer: markerRenderer,
        color,
        weight: mode === 'history' ? 1 : 1.2,
        opacity: 0.9,
        fillColor,
        fillOpacity: mode === 'history' ? 0.2 : 0.32,
      })
        // Right-click ‚Üí open in Google Maps (useful on desktop)
        .on('contextmenu', () => {
          window.open(gmaps, '_blank', 'noopener,noreferrer');
        })
        .bindPopup(popupHtml);
      return marker;
    }

    function _normalizeLocationToken(value) {
      return String(value || '').trim().toLowerCase();
    }

    function isUnknownLocation(incident) {
      const street = _normalizeLocationToken(incident?.street);
      const cross = _normalizeLocationToken(incident?.cross_streets);
      const streetUnknown = street === '' || street === 'unknown';
      const crossUnknown = cross === '' || cross === 'unknown';
      return streetUnknown && crossUnknown;
    }

    // Check if an incident has a valid, mappable location (not "Unknown")
    function hasValidLocation(incident) {
      if (!incident) return false;
      const lat = Number(incident.latitude);
      const lng = Number(incident.longitude);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return false;
      if (isUnknownLocation(incident)) return false;
      return true;
    }

    // Replace map markers with the given incident set (used for Live and History modes)
    function setMapMarkers(incidents, { fit = false, mode = mapMode } = {}) {
      // Filter out incidents with "Unknown" location
      const mappableIncidents = (incidents || []).filter(hasValidLocation);
      const nextIds = new Set(mappableIncidents.map(i => i.id));

      // Remove markers not in the next set
      markers.forEach((marker, id) => {
        if (!nextIds.has(id)) {
          if (map.hasLayer(marker)) map.removeLayer(marker);
          markers.delete(id);
        }
      });

      // Add missing markers
      mappableIncidents.forEach(incident => {
        if (!markers.has(incident.id)) {
          const marker = createMarker(incident, { mode });
          marker.addTo(map);
          markers.set(incident.id, marker);
        } else {
          const marker = markers.get(incident.id);
          if (marker && !map.hasLayer(marker)) marker.addTo(map);
        }
      });

      if (fit && mappableIncidents.length > 0) {
        try {
          const bounds = L.latLngBounds(mappableIncidents.map(i => [i.latitude, i.longitude]));
          map.fitBounds(bounds, { padding: [50, 50], maxZoom: 14 });
        } catch (e) {
          // ignore fit errors
        }
      }
    }
    
    // Format time
    function formatTime(time) {
      if (!time) return '--:--';
      const str = time.toString().padStart(4, '0');
      return `${str.slice(0, 2)}:${str.slice(2)}`;
    }

    function smoothFocusOnPoint(lat, lng, { targetZoom = 15 } = {}) {
      const center = L.latLng(Number(lat), Number(lng));
      const currentCenter = map.getCenter();
      const distanceKm = map.distance(currentCenter, center) / 1000;
      const currentZoom = map.getZoom();
      const zoomTarget = Math.max(currentZoom, targetZoom);

      map.stop();

      // Very long jumps feel better as an immediate reposition.
      if (distanceKm > 140) {
        map.setView(center, zoomTarget, { animate: false });
        return;
      }

      // Keep pans quick so the target is visible promptly.
      const duration = distanceKm > 60 ? 0.32 : 0.24;
      map.panTo(center, {
        animate: true,
        duration,
        easeLinearity: 0.25,
        noMoveStart: true,
      });

      if (currentZoom < zoomTarget) {
        map.once('moveend', () => {
          map.setZoom(zoomTarget, { animate: true });
        });
      }
    }
    
    // Create incident card
    function createIncidentCard(incident, isNew = false) {
      const sev = getSeverity(incident);
      const sevClass = getSeverityClass(sev);
      const agencyDisplay = formatAgencyDisplay(incident);
      const hasLocation = hasValidLocation(incident);
      const clickAttr = hasLocation ? ` onclick="focusIncident(${incident.latitude}, ${incident.longitude})"` : '';
      
      return `
        <div class="incident-card ${sevClass} ${isNew ? 'new' : ''}" 
             data-id="${incident.id}"${clickAttr}>
          <div class="incident-header">
            <span class="incident-type">${incident.description}</span>
            <span class="incident-time">${formatTime(incident.time)}</span>
          </div>
          <div class="incident-location">
            üìç ${[incident.street, incident.cross_streets].filter(Boolean).join(' @ ') || 'Unknown'}
          </div>
          <div class="incident-meta">
            <span class="incident-agency ${sevClass}" title="Severity: ${sev.toUpperCase()}">${agencyDisplay}</span>
            <span class="incident-units">${sev.toUpperCase()} ‚Ä¢ ${incident.units} unit(s) ‚Ä¢ ${incident.municipality}</span>
          </div>
        </div>
      `;
    }
    
    // Focus on incident on map
    window.focusIncident = function(lat, lng) {
      const nLat = Number(lat);
      const nLng = Number(lng);
      if (!Number.isFinite(nLat) || !Number.isFinite(nLng)) return;
      smoothFocusOnPoint(nLat, nLng, { targetZoom: 15 });
    };
    
    // Settings modal
    const settingsModal = document.getElementById('settings-modal');
    const settingsClose = document.getElementById('settings-close');
    const showAllHistoryToggle = document.getElementById('setting-show-all-history');
    
    // Load setting from localStorage (default: true - show all incidents on map)
    let showAllHistoryOnMap = localStorage.getItem('showAllHistoryOnMap') !== 'false';
    if (showAllHistoryToggle) {
      showAllHistoryToggle.checked = showAllHistoryOnMap;
    }
    
    // Store all incidents for the day (used when showAllHistoryOnMap is enabled)
    let allHistoryIncidentsForDay = [];
    
    window.toggleSettingsPanel = function(forceOpen) {
      if (!settingsModal) return;
      const next = typeof forceOpen === 'boolean' ? forceOpen : !settingsModal.classList.contains('open');
      settingsModal.classList.toggle('open', next);
      settingsModal.setAttribute('aria-hidden', String(!next));
      document.body.classList.toggle('modal-open', next);
    };
    
    settingsClose?.addEventListener('click', () => toggleSettingsPanel(false));
    settingsModal?.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-backdrop')) toggleSettingsPanel(false);
    });
    
    showAllHistoryToggle?.addEventListener('change', (e) => {
      showAllHistoryOnMap = e.target.checked;
      localStorage.setItem('showAllHistoryOnMap', String(showAllHistoryOnMap));
      // Refresh history view if we're on the history tab
      const historyPanel = document.getElementById('history-panel');
      if (historyPanel && !historyPanel.classList.contains('hidden')) {
        refreshHistoryMapMarkers();
      }
    });

    // Info modal
    const infoModal = document.getElementById('info-modal');
    const infoClose = document.getElementById('info-close');
    
    window.toggleInfoPanel = function(forceOpen) {
      if (!infoModal) return;
      const next = typeof forceOpen === 'boolean' ? forceOpen : !infoModal.classList.contains('open');
      infoModal.classList.toggle('open', next);
      infoModal.setAttribute('aria-hidden', String(!next));
      document.body.classList.toggle('modal-open', next);
    };
    
    infoClose?.addEventListener('click', () => toggleInfoPanel(false));
    infoModal?.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-backdrop')) toggleInfoPanel(false);
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && infoModal?.classList.contains('open')) toggleInfoPanel(false);
      if (e.key === 'Escape' && settingsModal?.classList.contains('open')) toggleSettingsPanel(false);
    });
    
    // Update incidents
    async function updateIncidents() {
      try {
        let response = await fetch(`api/incidents/active?${sourceQueryParam()}`);
        if (!response.ok && currentSource !== 'all') {
          // Backward-compat fallback for deployments where source-param filtering is unavailable.
          response = await fetch('api/incidents/active?source=all');
        }
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        let allIncidents = await response.json();
        allIncidents.forEach((incident) => {
          incident.source = normalizeSource(incident?.source);
        });
        if (currentSource !== 'all') {
          allIncidents = allIncidents.filter((incident) => normalizeSource(incident?.source) === currentSource);
        }
        
        // Store all incidents
        currentIncidents = allIncidents;

        // Only update shared filter visibility from the active feed when the Live tab is visible.
        // Otherwise History's filter visibility would get overridden every poll.
        const livePanel = document.getElementById('live-panel');
        const liveVisible = livePanel && !livePanel.classList.contains('hidden');
        if (liveVisible) updateFilterButtonVisibility(allIncidents);
        
        // Apply current filters (agency + urgency)
        const incidents = getFilteredIncidents(allIncidents);
        
        // Update counts
        document.getElementById('active-count').textContent = allIncidents.length;

        // If we're not on the Live tab, don't touch the map/list (History owns the map).
        if (!liveVisible) return;
        
        // Update map + list (filtered)
        setMapMarkers(incidents, { mode: 'live' });
        renderIncidentList(incidents);
        
      } catch (error) {
        console.error('Failed to fetch incidents:', error);
      }
    }
    
    // Render the incident list
    function renderIncidentList(incidents) {
      const listEl = document.getElementById('incident-list');
      const sorted = sortIncidents(incidents);
      const signature = buildIncidentListSignature(
        sorted,
        `live:${currentSource}:${currentSort}:${currentFilter}:${currentBatonRougeAgency}:${currentLafayetteUnit}:${currentUrgencyFilter}`
      );
      if (signature === lastLiveListSignature) return;
      lastLiveListSignature = signature;
      if (sorted.length === 0) {
        const hasAgencyFilter = currentUnitFilterValueForUi() !== 'all';
        const hasUrgencyFilter = currentUrgencyFilter !== 'all';
        const hasAnyFilter = hasAgencyFilter || hasUrgencyFilter;
        
        let label = 'active';
        if (hasAgencyFilter && hasUrgencyFilter) {
          label = `${urgencyLabel(currentUrgencyFilter)} ${currentUnitFilterLabelForUi()}`;
        } else if (hasAgencyFilter) {
          label = currentUnitFilterLabelForUi();
        } else if (hasUrgencyFilter) {
          label = urgencyLabel(currentUrgencyFilter);
        }
        
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="icon">üì°</div>
            <p>No ${label} incidents</p>
            <p style="font-size: 11px; margin-top: 10px;">${hasAnyFilter ? 'Try a different filter combination' : 'Waiting for data...'}</p>
          </div>
        `;
      } else {
        if (currentSource === 'all') {
          listEl.innerHTML = renderSourceGroups(sorted);
        } else {
          listEl.innerHTML = sorted.map(inc => createIncidentCard(inc, false)).join('');
        }
      }
    }
    
    // Apply agency filter and update display
    function applyAgencyFilter(filter) {
      const btn = document.querySelector(`.filter-group[data-filter-type="agency-caddo"] .filter-btn[data-filter="${filter}"]`);
      const isEmpty = filter !== 'all' && btn?.classList.contains('empty');
      if (isEmpty) {
        return;
      }
      currentFilter = filter;
      
      // Update Caddo unit button states.
      caddoFilterButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
      });

      refreshFilteredView();
      focusMapOnCurrentFilteredIncidents();
    }

    function applyBatonRougeAgencyFilter(agency) {
      const normalized = String(agency || '').toLowerCase();
      if (!['all', 'law', 'oss'].includes(normalized)) return;
      const btn = document.querySelector(`.filter-group[data-filter-type="agency-batonrouge"] .filter-btn[data-br-agency="${normalized}"]`);
      const isEmpty = normalized !== 'all' && btn?.classList.contains('empty');
      if (isEmpty) return;
      if (currentBatonRougeAgency === normalized) return;
      currentBatonRougeAgency = normalized;

      batonRougeFilterButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.brAgency === currentBatonRougeAgency);
      });

      refreshFilteredView();
      focusMapOnCurrentFilteredIncidents();
    }

    // Apply urgency filter and update display
    function applyUrgencyFilter(urgency) {
      const btn = document.querySelector(`.filter-group[data-filter-type="urgency"] .filter-btn[data-urgency="${urgency}"]`);
      const isEmpty = urgency !== 'all' && btn?.classList.contains('empty');
      if (isEmpty) {
        return;
      }
      currentUrgencyFilter = urgency;
      
      // Update urgency filter button states
      urgencyFilterButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.urgency === urgency);
      });

      refreshFilteredView();
      focusMapOnCurrentFilteredIncidents();
    }

    // Refresh the view with current filters applied
    function refreshFilteredView() {
      const livePanel = document.getElementById('live-panel');
      const historyPanel = document.getElementById('history-panel');
      const liveVisible = livePanel && !livePanel.classList.contains('hidden');
      const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');

      // Update filter button visibility/counts based on current filters
      if (liveVisible) {
        updateFilterButtonVisibility(currentIncidents);
      } else if (historyVisible) {
        updateFilterButtonVisibility(currentHistoryIncidents);
      }

      if (historyVisible) {
        const { pageData, skipSort } = getHistoryPageData(currentHistoryIncidents);
        renderHistoryList(pageData, historySelectedDate, { total: historyTotal, skipSort });
        
        // Use showAllHistoryOnMap setting for map markers
        if (showAllHistoryOnMap && allHistoryIncidentsForDay.length > 0) {
          const allFiltered = getFilteredIncidents(allHistoryIncidentsForDay, currentFilter, currentUrgencyFilter);
          setMapMarkers(allFiltered, { fit: false, mode: 'history' });
        } else {
          setMapMarkers(pageData, { fit: false, mode: 'history' });
        }
      } else if (liveVisible) {
        const filtered = getFilteredIncidents(currentIncidents);
        renderIncidentList(filtered);
        setMapMarkers(filtered, { fit: false, mode: 'live' });
      }
    }

    function focusMapOnCurrentFilteredIncidents() {
      const livePanel = document.getElementById('live-panel');
      const historyPanel = document.getElementById('history-panel');
      const liveVisible = livePanel && !livePanel.classList.contains('hidden');
      const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');

      let candidates = [];
      if (historyVisible) {
        if (showAllHistoryOnMap && allHistoryIncidentsForDay.length > 0) {
          candidates = getFilteredIncidents(allHistoryIncidentsForDay, currentFilter, currentUrgencyFilter);
        } else {
          const { pageData } = getHistoryPageData(currentHistoryIncidents);
          candidates = pageData;
        }
      } else if (liveVisible) {
        candidates = getFilteredIncidents(currentIncidents);
      }

      const mappable = (candidates || []).filter(hasValidLocation);
      if (!mappable.length) return;

      if (mappable.length === 1) {
        const incident = mappable[0];
        smoothFocusOnPoint(incident.latitude, incident.longitude, { targetZoom: 15 });
        return;
      }

      try {
        const bounds = L.latLngBounds(mappable.map(i => [i.latitude, i.longitude]));
        map.fitBounds(bounds, { padding: [50, 50], maxZoom: 14 });
      } catch (e) {
        // ignore map-fit errors
      }
    }
    
    // Update last update time
    async function updateStatus() {
      try {
        const response = await fetch('api/status');
        const status = await response.json();

        const el = document.getElementById('last-update');

        if (status.centralDate) {
          const prevToday = isoToday;
          isoToday = status.centralDate;
          if (historySelectedDate === prevToday) {
            setHistoryDate(status.centralDate, { load: false });
          } else {
            renderDatePicker();
          }
        }

        // Prefer the upstream Caddo911 "Refreshed at:" timestamp if available.
        if (status.feedRefreshedAt) {
          const tz = status.centralTzAbbr || 'CT';
          el.textContent = `${status.feedRefreshedAt} ${tz}`;
        } else if (status.lastUpdateDisplay) {
          el.textContent = status.lastUpdateDisplay;
        } else if (status.lastScrapeFinishedAt || status.lastUpdate) {
          // Fallback: if the backend didn't provide Central-time strings, show local time.
          const date = new Date(status.lastScrapeFinishedAt || status.lastUpdate);
          el.textContent = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }

        // Helpful hover text
        if (status.lastUpdateTooltip) {
          el.title = `Server scrape (Central): ${status.lastUpdateTooltip}`;
        } else {
          const scraped = status.lastScrapeFinishedAt || status.lastUpdate;
          el.title = scraped ? `Server scrape: ${new Date(scraped).toLocaleString()}` : '';
        }
        return typeof status.scrapeInterval === 'number' ? status.scrapeInterval : null;
      } catch (error) {
        console.error('Failed to fetch status:', error);
        return null;
      }
    }
    
    // Refresh history map markers based on current settings
    function refreshHistoryMapMarkers() {
      const historyPanel = document.getElementById('history-panel');
      if (!historyPanel || historyPanel.classList.contains('hidden')) return;
      
      if (showAllHistoryOnMap && allHistoryIncidentsForDay.length > 0) {
        // Show all incidents for the day on the map
        const filteredAll = getFilteredIncidents(allHistoryIncidentsForDay, currentFilter, currentUrgencyFilter);
        setMapMarkers(filteredAll, { fit: true, mode: 'history' });
      } else {
        // Show only current page incidents
        const filteredPage = getFilteredIncidents(currentHistoryIncidents, currentFilter, currentUrgencyFilter);
        const offset = (historyPage - 1) * historyPageSize;
        let pageData;
        if (currentSort === 'urgency') {
          const sortedAll = sortIncidents(filteredPage);
          pageData = sortedAll.slice(offset, offset + historyPageSize);
        } else {
          pageData = filteredPage;
        }
        setMapMarkers(pageData, { fit: true, mode: 'history' });
      }
    }
    
    // Find which page an incident is on (for click-to-navigate)
    function findIncidentPage(incidentId) {
      if (!allHistoryIncidentsForDay || allHistoryIncidentsForDay.length === 0) return 1;
      const filteredAll = getFilteredIncidents(allHistoryIncidentsForDay, currentFilter, currentUrgencyFilter);
      const sorted = sortIncidents(filteredAll);
      const index = sorted.findIndex(inc => inc.id === incidentId);
      if (index === -1) return 1;
      return Math.floor(index / historyPageSize) + 1;
    }
    
    // Navigate to a specific page and highlight the incident
    async function navigateToIncidentPage(incidentId) {
      const targetPage = findIncidentPage(incidentId);
      if (targetPage !== historyPage) {
        historyPage = targetPage;
        await loadHistory(historySelectedDate);
      }
      // Scroll to and highlight the incident card
      setTimeout(() => {
        const card = document.querySelector(`.incident-card[data-id="${incidentId}"]`);
        if (card) {
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          card.classList.add('highlighted');
          setTimeout(() => card.classList.remove('highlighted'), 5000);
        }
      }, 100);
    }

    // Load history
    async function loadHistory(date) {
      try {
        const offset = (historyPage - 1) * historyPageSize;
        const params = new URLSearchParams();
        params.set('source', currentSource);
        if (date) params.set('date', date);
        params.set('limit', String(historyPageSize));
        params.set('offset', String(offset));
        const pageUrl = `api/incidents/history?${params.toString()}`;
        const response = await fetch(pageUrl);
        const data = await response.json();

        let incidents = Array.isArray(data.incidents) ? data.incidents : [];
        let total = Number(data.total || 0);
        incidents.forEach((incident) => {
          incident.source = normalizeSource(incident?.source);
        });

        // If we need all incidents (for urgency sort OR for showing all on map), fetch them
        const needAllIncidents = currentSort === 'urgency' || showAllHistoryOnMap;
        if (needAllIncidents && total > incidents.length) {
          const fullParams = new URLSearchParams();
          fullParams.set('source', currentSource);
          if (date) fullParams.set('date', date);
          fullParams.set('limit', String(total));
          fullParams.set('offset', '0');
          const fullUrl = `api/incidents/history?${fullParams.toString()}`;
          const fullResponse = await fetch(fullUrl);
          const fullData = await fullResponse.json();
          incidents = Array.isArray(fullData.incidents) ? fullData.incidents : incidents;
          incidents.forEach((incident) => {
            incident.source = normalizeSource(incident?.source);
          });
          total = Number(fullData.total || total);
        }
        historyHasAllIncidents = incidents.length >= total;

        currentHistoryIncidents = incidents;
        historyTotal = total;
        
        // Store all incidents for the day (used when showAllHistoryOnMap is enabled)
        if (showAllHistoryOnMap) {
          allHistoryIncidentsForDay = incidents;
        }
        
        // Only update shared filter visibility from History when the History tab is visible.
        const historyPanel = document.getElementById('history-panel');
        const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');
        if (historyVisible) {
          updateFilterButtonVisibility(currentHistoryIncidents);
        }
        const { pageData, skipSort } = getHistoryPageData(currentHistoryIncidents);
        
        updateHistoryCount(historyTotal, date);
        updateHistoryPagination();
        // Pass skipSort flag so we don't re-sort already-sorted urgency data
        renderHistoryList(pageData, date, { total: historyTotal, skipSort });

        // Replace map markers with history results when History tab is active
        if (historyVisible) {
          if (showAllHistoryOnMap && allHistoryIncidentsForDay.length > 0) {
            // Show all incidents for the day on map
            const allFiltered = getFilteredIncidents(allHistoryIncidentsForDay, currentFilter, currentUrgencyFilter);
            setMapMarkers(allFiltered, { fit: true, mode: 'history' });
          } else {
            // Show only current page
            setMapMarkers(pageData, { fit: true, mode: 'history' });
          }
        }
      } catch (error) {
        console.error('Failed to fetch history:', error);
      }
    }

    function updateHistoryCount(total, date) {
      const countWrap = document.getElementById('history-count');
      const countValue = document.getElementById('history-count-value');
      const countLabel = document.getElementById('history-count-label');
      if (!countWrap || !countValue) return;
      const isToday = Boolean(date && date === isoToday);
      if (countLabel) {
        countLabel.textContent = isToday ? 'Today' : 'Incidents';
      }
      countWrap.classList.toggle('today', isToday);
      countWrap.classList.toggle('incidents', !isToday);
      countValue.textContent = total.toString();
      countWrap.classList.remove('hidden');
    }

    function updateHistoryPagination() {
      const pagination = document.getElementById('history-pagination');
      const status = document.getElementById('history-page-status');
      const prev = document.getElementById('history-prev');
      const next = document.getElementById('history-next');
      if (!pagination || !status || !prev || !next) return;

      const totalPages = Math.max(1, Math.ceil(historyTotal / historyPageSize));
      historyPage = Math.min(Math.max(historyPage, 1), totalPages);
      status.textContent = `Page ${historyPage} of ${totalPages}`;
      prev.disabled = historyPage <= 1;
      next.disabled = historyPage >= totalPages;
      pagination.classList.toggle('hidden', totalPages <= 1);
    }

    function renderHistoryList(incidents, date, { total = 0, skipSort = false } = {}) {
      const listEl = document.getElementById('history-list');
      const dateLabel = date
        ? new Date(`${date}T00:00:00`).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' })
        : 'selected date';
      const sorted = skipSort ? incidents : sortIncidents(incidents);
      const signature = buildIncidentListSignature(
        sorted,
        `history:${date || 'none'}:${total}:${historyPage}:${currentSource}:${currentSort}:${currentFilter}:${currentBatonRougeAgency}:${currentLafayetteUnit}:${currentUrgencyFilter}`
      );
      if (signature === lastHistoryListSignature) return;
      lastHistoryListSignature = signature;

      if (total === 0) {
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="icon">üìã</div>
            <p>No incidents available for</p>
            <p style="font-size: 12px; margin-top: 6px; color: var(--text); font-weight: 600;">${dateLabel}</p>
            <p style="font-size: 11px; margin-top: 10px;">Try another date (or the cache may not include that day yet).</p>
          </div>
        `;
        return;
      }

      if (sorted.length === 0) {
        const hasAgencyFilter = currentUnitFilterValueForUi() !== 'all';
        const hasUrgencyFilter = currentUrgencyFilter !== 'all';
        
        let filterLabelStr = 'incidents';
        if (hasAgencyFilter && hasUrgencyFilter) {
          filterLabelStr = `${urgencyLabel(currentUrgencyFilter)} ${currentUnitFilterLabelForUi()} incidents`;
        } else if (hasAgencyFilter) {
          filterLabelStr = `${currentUnitFilterLabelForUi()} incidents`;
        } else if (hasUrgencyFilter) {
          filterLabelStr = `${urgencyLabel(currentUrgencyFilter)} incidents`;
        }
        
        listEl.innerHTML = `
          <div class="empty-state">
            <div class="icon">üìã</div>
            <p>No ${filterLabelStr} for</p>
            <p style="font-size: 12px; margin-top: 6px; color: var(--text); font-weight: 600;">${dateLabel}</p>
            <p style="font-size: 11px; margin-top: 10px;">Try another filter combination or date.</p>
          </div>
        `;
        return;
      }

      if (currentSource === 'all') {
        listEl.innerHTML = renderSourceGroups(sorted);
      } else {
        listEl.innerHTML = sorted.map(inc => createIncidentCard(inc, false)).join('');
      }
    }

    // Inline History date picker (no browser-native date input)
    const historyDateBtn = document.getElementById('history-date-btn');
    const historyDateValue = document.getElementById('history-date-value');
    const datePickerEl = document.getElementById('date-picker');

    function pad2(n) {
      return String(n).padStart(2, '0');
    }

    function formatIsoDate(year, month, day) {
      return `${year}-${pad2(month)}-${pad2(day)}`;
    }

    function getCentralIsoDateFallback() {
      try {
        return new Intl.DateTimeFormat('en-CA', {
          timeZone: 'America/Chicago',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit'
        }).format(new Date());
      } catch (error) {
        const d = new Date();
        return formatIsoDate(d.getFullYear(), d.getMonth() + 1, d.getDate());
      }
    }

    let isoToday = getCentralIsoDateFallback();
    let historySelectedDate = isoToday;
    let historyViewMonth = (() => {
      const d = parseISODate(isoToday);
      d.setDate(1);
      return d;
    })();
    const historyCountsByMonth = new Map();

    function monthKeyFromDate(date, source = currentSource) {
      return `${source}:${date.getFullYear()}-${pad2(date.getMonth() + 1)}`;
    }

    function isoFromParts(year, monthIndex, day) {
      return `${year}-${pad2(monthIndex + 1)}-${pad2(day)}`;
    }

    function parseISODate(iso) {
      const [y, m, d] = iso.split('-').map(Number);
      return new Date(y, (m || 1) - 1, d || 1);
    }

    function getFrequencyClass(count) {
      if (count > 100) return 'freq-high';
      if (count >= 26) return 'freq-medium';
      if (count >= 1) return 'freq-low';
      return '';
    }

    async function loadHistoryCountsForMonth(date) {
      const monthKey = monthKeyFromDate(date);
      if (historyCountsByMonth.has(monthKey)) return;

      try {
        const month = `${date.getFullYear()}-${pad2(date.getMonth() + 1)}`;
        const response = await fetch(`api/incidents/history_counts?month=${month}&source=${encodeURIComponent(currentSource)}`);
        if (!response.ok) throw new Error(`History counts request failed: ${response.status}`);
        const data = await response.json();
        const counts = data && typeof data === 'object' ? (data.counts || {}) : {};
        historyCountsByMonth.set(monthKey, counts);
      } catch (error) {
        console.error('Failed to fetch history counts:', error);
        historyCountsByMonth.set(monthKey, {});
      }
    }

    function getHistoryCount(isoDate) {
      const monthKey = `${currentSource}:${isoDate.slice(0, 7)}`;
      const monthCounts = historyCountsByMonth.get(monthKey);
      return Number(monthCounts?.[isoDate] || 0);
    }

    function setHistoryDate(iso, { load = true } = {}) {
      historySelectedDate = iso;
      historyDateValue.textContent = iso;
      const d = parseISODate(iso);
      d.setDate(1);
      historyViewMonth = d;
      historyPage = 1;
      if (load) loadHistory(iso);
      renderDatePicker();
    }

    function toggleDatePicker(forceOpen) {
      const next = typeof forceOpen === 'boolean' ? forceOpen : !datePickerEl.classList.contains('open');
      datePickerEl.classList.toggle('open', next);
      datePickerEl.setAttribute('aria-hidden', String(!next));
      historyDateBtn.setAttribute('aria-expanded', String(next));
      if (next) renderDatePicker();
    }

    function renderDatePicker() {
      if (!datePickerEl.classList.contains('open')) return;

      const year = historyViewMonth.getFullYear();
      const month = historyViewMonth.getMonth();
      const firstDow = new Date(year, month, 1).getDay(); // 0=Sun
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      const monthKey = monthKeyFromDate(historyViewMonth);
      const monthCounts = historyCountsByMonth.get(monthKey);

      if (!monthCounts) {
        loadHistoryCountsForMonth(historyViewMonth).then(() => {
          if (datePickerEl.classList.contains('open')) renderDatePicker();
        });
      }

      const monthLabel = historyViewMonth.toLocaleString('en-US', { month: 'long', year: 'numeric' });
      const dows = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

      let html = `
        <div class="dp-header">
          <button type="button" class="dp-nav" data-action="prev" aria-label="Previous month">‚Äπ</button>
          <div class="dp-month">${monthLabel}</div>
          <button type="button" class="dp-nav" data-action="next" aria-label="Next month">‚Ä∫</button>
        </div>
        <div class="dp-grid">
          ${dows.map(d => `<div class="dp-dow">${d}</div>`).join('')}
      `;

      // Leading empties
      for (let i = 0; i < firstDow; i++) {
        html += `<button type="button" class="dp-day empty" tabindex="-1" disabled></button>`;
      }

      for (let day = 1; day <= daysInMonth; day++) {
        const iso = isoFromParts(year, month, day);
        const isSelected = iso === historySelectedDate;
        const isToday = iso === isoToday;
        const count = monthCounts ? getHistoryCount(iso) : 0;
        const freqClass = getFrequencyClass(count);
        const cls = [
          'dp-day',
          freqClass,
          isSelected ? 'selected' : '',
          isToday ? 'today' : ''
        ].filter(Boolean).join(' ');
        const label = count > 0 ? `${count} incident${count === 1 ? '' : 's'}` : 'No incidents';
        html += `<button type="button" class="${cls}" data-date="${iso}" title="${label}">${day}</button>`;
      }

      // Trailing empties to fill last row (up to 42 day cells + 7 dows)
      const totalCells = firstDow + daysInMonth;
      const trailing = (7 - (totalCells % 7)) % 7;
      for (let i = 0; i < trailing; i++) {
        html += `<button type="button" class="dp-day empty" tabindex="-1" disabled></button>`;
      }

      html += `</div>`;
      datePickerEl.innerHTML = html;
    }

    historyDateBtn.addEventListener('click', () => toggleDatePicker());

    datePickerEl.addEventListener('click', (e) => {
      const action = e.target.closest('button[data-action]')?.dataset.action;
      if (action === 'prev') {
        historyViewMonth = new Date(historyViewMonth.getFullYear(), historyViewMonth.getMonth() - 1, 1);
        renderDatePicker();
        return;
      }
      if (action === 'next') {
        historyViewMonth = new Date(historyViewMonth.getFullYear(), historyViewMonth.getMonth() + 1, 1);
        renderDatePicker();
        return;
      }

      const date = e.target.closest('button[data-date]')?.dataset.date;
      if (date) {
        setHistoryDate(date, { load: true });
        toggleDatePicker(false);
      }
    });

    // History pagination
    const historyPrev = document.getElementById('history-prev');
    const historyNext = document.getElementById('history-next');

    function scrollHistoryListToTop() {
      const historyList = document.getElementById('history-list');
      if (historyList) historyList.scrollTop = 0;
    }

    historyPrev?.addEventListener('click', () => {
      if (historyPage <= 1) return;
      historyPage -= 1;
      loadHistory(historySelectedDate);
      scrollHistoryListToTop();
    });

    historyNext?.addEventListener('click', () => {
      const totalPages = Math.max(1, Math.ceil(historyTotal / historyPageSize));
      if (historyPage >= totalPages) return;
      historyPage += 1;
      loadHistory(historySelectedDate);
      scrollHistoryListToTop();
    });

    // Close date picker when clicking outside of it
    document.addEventListener('click', (e) => {
      if (!datePickerEl.classList.contains('open')) return;
      const clickPath = typeof e.composedPath === 'function' ? e.composedPath() : [];
      const clickedInsidePicker = clickPath.includes(datePickerEl) || datePickerEl.contains(e.target);
      const clickedDateButton = clickPath.includes(historyDateBtn) || historyDateBtn.contains(e.target);
      if (clickedInsidePicker || clickedDateButton) return;
      toggleDatePicker(false);
    });

    function applyLafayetteUnitFilter(unit) {
      const normalized = String(unit || '').toLowerCase();
      if (!['all', 'police', 'sheriff', 'fire'].includes(normalized)) return;
      const btn = document.querySelector(`.filter-group[data-filter-type="agency-lafayette"] .filter-btn[data-laf-unit="${normalized}"]`);
      const isEmpty = normalized !== 'all' && btn?.classList.contains('empty');
      if (isEmpty) return;
      if (currentLafayetteUnit === normalized) return;
      currentLafayetteUnit = normalized;

      document.querySelectorAll('.filter-group[data-filter-type="agency-lafayette"] .filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lafUnit === currentLafayetteUnit);
      });

      refreshFilteredView();
      focusMapOnCurrentFilteredIncidents();
    }

    function setAgencyButtonView(view) {
      const normalized = ['caddo', 'batonrouge', 'lafayette'].includes(view) ? view : 'caddo';
      agencyButtonView = normalized;

      const caddoGroup = document.querySelector('.agency-group-caddo');
      const batonRougeGroup = document.querySelector('.agency-group-batonrouge');
      const lafayetteGroup = document.querySelector('.agency-group-lafayette');
      if (caddoGroup) caddoGroup.classList.toggle('hidden', normalized !== 'caddo');
      if (batonRougeGroup) batonRougeGroup.classList.toggle('hidden', normalized !== 'batonrouge');
      if (lafayetteGroup) lafayetteGroup.classList.toggle('hidden', normalized !== 'lafayette');

      const controls = document.getElementById('agency-bank-controls');
      if (controls) {
        controls.classList.toggle('hidden', currentSource !== 'all');
      }

      document.querySelectorAll('.agency-bank-btn').forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.agencyView === normalized);
      });
    }

    function syncAgencyButtonViewToSource() {
      if (currentSource === 'batonrouge') {
        setAgencyButtonView('batonrouge');
        return;
      }
      if (currentSource === 'lafayette') {
        setAgencyButtonView('lafayette');
        return;
      }
      if (currentSource === 'all') {
        // In "All", keep whichever side the user last picked.
        setAgencyButtonView(agencyButtonView);
        return;
      }
      // Caddo uses the Caddo unit filter bank.
      setAgencyButtonView('caddo');
    }

    function applySourceFilter(source) {
      const normalized = String(source || '').toLowerCase();
      if (!['all', 'caddo', 'batonrouge', 'lafayette'].includes(normalized)) return;
      if (currentSource === normalized) {
        focusMapOnSourceSelection(normalized);
        return;
      }

      currentSource = normalized;
      historyPage = 1;
      historyCountsByMonth.clear();
      allHistoryIncidentsForDay = [];

      document.querySelectorAll('.source-tab').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.source === currentSource);
      });
      syncAgencyButtonViewToSource();
      focusMapOnSourceSelection(currentSource);

      const historyPanel = document.getElementById('history-panel');
      const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');
      if (historyVisible) {
        loadHistory(historySelectedDate);
      } else {
        updateIncidents();
      }
    }

    document.querySelectorAll('.source-tab').forEach(btn => {
      btn.addEventListener('click', () => {
        applySourceFilter(btn.dataset.source);
      });
    });
    
    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        const tabName = tab.dataset.tab;
        document.getElementById('live-panel').classList.toggle('hidden', tabName !== 'live');
        document.getElementById('history-panel').classList.toggle('hidden', tabName !== 'history');
        
        if (tabName === 'history') {
          mapMode = 'history';
          // Clear live markers immediately; history will repopulate after fetch
          setMapMarkers([], { mode: 'history' });
          // Make sure the date UI is initialized and load that date's cache
          setHistoryDate(historySelectedDate, { load: true });
          toggleDatePicker(false);
        } else {
          mapMode = 'live';
          const countWrap = document.getElementById('history-count');
          if (countWrap) countWrap.classList.add('hidden');
          // Live tab: make filter visibility reflect the active feed immediately
          updateFilterButtonVisibility(currentIncidents);
          // Render live markers immediately from the last-known active incidents
          setMapMarkers(getFilteredIncidents(currentIncidents), { fit: false, mode: 'live' });
          toggleDatePicker(false);
        }
      });
    });
    
    // Caddo unit filter button handlers
    caddoFilterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        applyAgencyFilter(btn.dataset.filter);
      });
    });

    // Baton Rouge agency filter button handlers
    batonRougeFilterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        applyBatonRougeAgencyFilter(btn.dataset.brAgency);
      });
    });

    // Lafayette unit filter button handlers
    lafayetteFilterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        applyLafayetteUnitFilter(btn.dataset.lafUnit);
      });
    });

    // Urgency filter button handlers
    urgencyFilterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        applyUrgencyFilter(btn.dataset.urgency);
      });
    });

    // Sort control + agency bank controls
    const agencyBankButtons = document.querySelectorAll('.agency-bank-btn');
    const sortToggle = document.getElementById('sort-toggle');
    const sortMenu = document.getElementById('sort-menu');

    function setSort(mode) {
      currentSort = mode === 'urgency' ? 'urgency' : 'recent';
      sortMenu?.querySelectorAll('.sort-option').forEach(option => {
        option.classList.toggle('active', option.dataset.sort === currentSort);
      });

      const livePanel = document.getElementById('live-panel');
      const historyPanel = document.getElementById('history-panel');
      const liveVisible = livePanel && !livePanel.classList.contains('hidden');
      const historyVisible = historyPanel && !historyPanel.classList.contains('hidden');

      if (historyVisible) {
        // For history, we might need to refetch if switching to urgency sort
        // and we don't have all incidents yet
        if (currentSort === 'urgency' && currentHistoryIncidents.length < historyTotal) {
          loadHistory(historySelectedDate);
          return;
        }
        
        const { pageData, skipSort } = getHistoryPageData(currentHistoryIncidents);
        renderHistoryList(pageData, historySelectedDate, { total: historyTotal, skipSort });
        
        // Also refresh map markers (but don't change what's shown based on sort - that's controlled by setting)
        if (showAllHistoryOnMap && allHistoryIncidentsForDay.length > 0) {
          // Already showing all, no need to update map
        } else {
          setMapMarkers(pageData, { fit: false, mode: 'history' });
        }
      } else if (liveVisible) {
        const filtered = getFilteredIncidents(currentIncidents);
        renderIncidentList(filtered);
      }
    }

    function toggleSortMenu(forceOpen) {
      if (!sortMenu || !sortToggle) return;
      const next = typeof forceOpen === 'boolean' ? forceOpen : !sortMenu.classList.contains('open');
      sortMenu.classList.toggle('open', next);
      sortMenu.setAttribute('aria-hidden', String(!next));
      sortToggle.setAttribute('aria-expanded', String(next));
    }

    sortToggle?.addEventListener('click', () => toggleSortMenu());
    sortMenu?.addEventListener('click', (e) => {
      const mode = e.target.closest('button[data-sort]')?.dataset.sort;
      if (!mode) return;
      setSort(mode);
      toggleSortMenu(false);
    });

    agencyBankButtons.forEach((btn) => {
      btn.addEventListener('click', () => {
        if (currentSource !== 'all') return;
        setAgencyButtonView(btn.dataset.agencyView);
      });
    });

    document.addEventListener('click', (e) => {
      if (!sortMenu?.classList.contains('open')) return;
      if (sortMenu.contains(e.target) || sortToggle?.contains(e.target)) return;
      toggleSortMenu(false);
    });

    // Mobile incidents bottom sheet
    const sidebar = document.querySelector('.sidebar');
    const panelToggle = document.getElementById('panel-toggle');
    const mobileQuery = window.matchMedia('(max-width: 720px)');

    function setMobilePanelOpen(open) {
      if (!sidebar) return;
      sidebar.classList.toggle('collapsed', !open);
      document.body.classList.toggle('mobile-incidents-open', open);
      if (panelToggle) {
        panelToggle.setAttribute('aria-expanded', String(open));
        panelToggle.textContent = open ? '‚ñº' : '‚ñ≤';
        panelToggle.title = open ? 'Collapse incidents' : 'Expand incidents';
      }
    }

    function syncMobilePanel() {
      const isMobile = mobileQuery.matches;
      document.body.classList.toggle('mobile-view', isMobile);
      if (!isMobile) {
        sidebar?.classList.remove('collapsed');
        document.body.classList.remove('mobile-incidents-open');
        if (panelToggle) {
          panelToggle.setAttribute('aria-expanded', 'true');
          panelToggle.textContent = '‚ñº';
          panelToggle.title = 'Collapse incidents';
        }
        return;
      }
      if (!document.body.classList.contains('mobile-incidents-open')) {
        setMobilePanelOpen(false);
      }
    }

    panelToggle?.addEventListener('click', () => {
      const isCollapsed = sidebar?.classList.contains('collapsed');
      setMobilePanelOpen(Boolean(isCollapsed));
    });

    mobileQuery.addEventListener('change', syncMobilePanel);
    window.addEventListener('load', syncMobilePanel);
    syncMobilePanel();

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js?v=3.2.91LAbeta', { updateViaCache: 'none' })
          .then((registration) => registration.update())
          .catch((error) => {
            console.warn('Service worker registration failed:', error);
          });
      });
    }
    
    // Initialize History date UI (default to today)
    setHistoryDate(isoToday, { load: false });
    syncAgencyButtonViewToSource();
    
    // Polling interval (ms). Keep at least 60s to be gentle.
    let pollIntervalMs = 60000;

    // Initial load
    loadParishOutline();
    updateIncidents();
    updateStatus();
    
    // Poll for updates with dynamic interval from /api/status.
    // This keeps chatter low and aligned with backend scrape cadence.
    async function pollLoop() {
      await updateIncidents();
      const nextInterval = await updateStatus();
      if (typeof nextInterval === 'number' && Number.isFinite(nextInterval)) {
        pollIntervalMs = Math.max(60000, Math.round(nextInterval));
      }
      setTimeout(pollLoop, pollIntervalMs);
    }

    setTimeout(pollLoop, pollIntervalMs);
  </script>
</body>
</html>
